<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ランナー（図鑑ミニゲーム）</title>
<style>
:root{
  --bg:#0b1422; --card:#111827; --ink:#e5e7eb; --line:#1f2937;
  --accent:#22d3ee; --warn:#f59e0b; --good:#22c55e;
  --frame:32px; --scale:3.2;
  --lane1: 20%; --lane2: 50%; --lane3: 80%;
  --stage-w: 420px;
  --stage-h: min(78svh, 680px); /* ←下の見切れ対策 */
  --grid-dur: 1.2s; /* 背景の流れ */
  --walk-dur: .75s;  /* 足踏み速度（大きいほどゆっくり） */
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,"Segoe UI",Roboto}
.wrap{max-width:calc(var(--stage-w) + 24px); margin:14px auto; padding:0 12px; display:grid; gap:10px}
.header{display:flex; justify-content:space-between; align-items:center; gap:8px}
.btn{background:#243042; color:#e5e7eb; padding:8px 12px; border-radius:10px; border:1px solid #2a3a51; text-decoration:none}
.btn.primary{background:var(--accent); color:#05202a; border:none; font-weight:700}
.meta{display:flex; gap:10px; align-items:center; font-weight:700}
.meta .score{color:#a5f3fc}
.meta .best{color:#86efac}
.stage{
  position:relative;
  width: min(92vw, var(--stage-w));
  height: var(--stage-h);
  margin:0 auto;
  border:1px solid #0f2a46; border-radius:16px; overflow:hidden;
  background:radial-gradient(ellipse at 40% 20%, #0f2438, #0b1a2b 60%);
}
.grid-bg{position:absolute; inset:0; pointer-events:none;
  background-image:
    linear-gradient(#173956 1px, transparent 1px),
    linear-gradient(90deg, #173956 1px, transparent 1px);
  background-size:40px 40px; opacity:.35;
  animation:gridMove var(--grid-dur) linear infinite;
}
@keyframes gridMove { to { background-position: 0 40px, 0 40px; } }
.char{
  position:absolute; bottom: 36px; left:50%;
  width:var(--frame); height:var(--frame);
  transform: translate(-50%, 0) scale(var(--scale));
  transform-origin:bottom center;
  image-rendering:pixelated;
  background-repeat:no-repeat; background-position:0 0;
  z-index:3;
}
.walking{ animation: walkAnim var(--walk-dur) steps(3) infinite; }
@keyframes walkAnim { from { background-position-x: 0px; } to { background-position-x: -96px; } }
.obstacle{
  position:absolute; top:-60px; width:48px; height:48px; border-radius:10px;
  background:#ef4444; border:2px solid #7f1d1d; box-shadow:0 0 12px rgba(239,68,68,.3);
  z-index:2;
}
.item{
  position:absolute; top:-52px; width:40px; height:40px; border-radius:50%;
  background:#10b981; border:2px solid #064e3b; box-shadow:0 0 10px rgba(16,185,129,.35);
  z-index:2;
}
.overlay{ position:absolute; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.55); }
.overlay[hidden]{display:none}
.sheet{background:#0f172a; border:1px solid #1e2f47; border-radius:14px; padding:16px; width:min(92%, 420px); display:grid; gap:10px; text-align:center}
.title{font-weight:800; font-size:20px}
.big{font-size:26px}
.small{color:#9ca3af}
.help{color:#9ca3af; font-size:12px; text-align:center}
kbd{background:#0a1320; border:1px solid #1a2a45; border-radius:6px; padding:2px 6px}
.footer{display:flex; justify-content:space-between; align-items:center}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <a class="btn" href="../index.html">← 図鑑に戻る</a>
    <div class="meta">
      <div>スコア <span class="score" id="score">0</span></div>
      <div>BEST <span class="best" id="best">0</span></div>
    </div>
    <button class="btn" id="pauseBtn">⏸ 一時停止</button>
  </div>

  <div class="stage" id="stage">
    <div class="grid-bg" id="gridBg"></div>
    <div class="char walking" id="hero" title="主人公"></div>

    <div class="overlay" id="gameOver" hidden>
      <div class="sheet">
        <div class="title">ゲームオーバー</div>
        <div class="big">スコア <span id="finalScore">0</span></div>
        <div class="small">ベスト <span id="finalBest">0</span></div>
        <div class="footer">
          <a class="btn" href="" id="retry">↻ もう一度</a>
          <a class="btn primary" href="../index.html">📚 図鑑へ</a>
        </div>
      </div>
    </div>

    <div class="overlay" id="howto">
      <div class="sheet">
        <div class="title">左右でレーン移動・障害物回避！</div>
        <div>PC: <kbd>←</kbd> <kbd>→</kbd> / <kbd>A</kbd> <kbd>D</kbd>　｜　スマホ: 左右スワイプ</div>
        <div class="small">緑アイテムはボーナス +50</div>
        <button class="btn primary" id="startBtn">▶︎ スタート</button>
      </div>
    </div>
  </div>

  <div class="help">ヒント：図鑑から選んだスキンで走ります。未指定なら <code>dex_state_v1.selected</code> を使用。</div>
</div>

<script>
const DEX_KEY = 'dex_state_v1';
function loadDex(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY)||'{}'); }catch{ return {}; } }

const qs = new URLSearchParams(location.search);
const skinParam = qs.get('skin');
const ASSET_BASES = ['../../project-root/','../project-root/','/pages/characters/project-root/','/project-root/'];

const stage = document.getElementById('stage');
const hero  = document.getElementById('hero');
const grid  = document.getElementById('gridBg');
const scoreEl = document.getElementById('score');
const bestEl  = document.getElementById('best');
const over  = document.getElementById('gameOver');
const finalScore = document.getElementById('finalScore');
const finalBest  = document.getElementById('finalBest');
const retry = document.getElementById('retry');
const howto = document.getElementById('howto');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');

(async function applySkin(){
  const dex = loadDex();
  const filename = skinParam || dex?.selected || 'char.png';
  for (const base of ASSET_BASES){
    const url = base + filename;
    const ok = await new Promise(res=>{
      const img = new Image(); img.onload=()=>res(true); img.onerror=()=>res(false); img.src = url + '?v=' + Date.now();
    });
    if(ok){ hero.style.backgroundImage = `url("${url}")`; break; }
  }
})();

const lanes = [ '20%', '50%', '80%' ];
let laneIdx = 1; // 中央スタート
let speed = 220; // px/秒
let spawnGap = 950; // ms
let lastSpawn = 0;
let running = false;
let score = 0;
let best = +(localStorage.getItem('runner_best')||0);
let rafStarted = false; // ← ループを一度だけ開始するフラグ
bestEl.textContent = best;

const obstacles = new Set();
function setLane(idx){
  laneIdx = Math.max(0, Math.min(2, idx));
  hero.style.left = lanes[laneIdx];
}
setLane(laneIdx);

function spawn(){
  const kind = Math.random()<0.2 ? 'item' : 'ob';
  const el = document.createElement('div');
  el.className = kind==='item' ? 'item' : 'obstacle';
  const pos = Math.floor(Math.random()*3);
  el.style.left = lanes[pos];
  stage.appendChild(el);
  obstacles.add({el, y:-60, kind});
}
function aabb(el1, el2){
  const r1 = el1.getBoundingClientRect();
  const r2 = el2.getBoundingClientRect();
  return !(r1.right < r2.left || r1.left > r2.right || r1.bottom < r2.top || r1.top > r2.bottom);
}

let last = 0;
function loop(ts){
  if(!running){ requestAnimationFrame(loop); return; }
  if(!last) last = ts;
  const dt = (ts - last)/1000;
  last = ts;

  score += dt * 10;
  scoreEl.textContent = Math.floor(score);
  speed  += dt * 3;
  spawnGap = Math.max(520, spawnGap - dt*20);

  if (ts - lastSpawn > spawnGap){
    spawn();
    lastSpawn = ts;
  }

  for (const obj of Array.from(obstacles)){
    obj.y += speed * dt;
    obj.el.style.transform = `translateY(${obj.y}px)`;

    const removeAt = stage.clientHeight + 80; // ← 画面高さに追従
    if (obj.y > removeAt){
      obj.el.remove();
      obstacles.delete(obj);
      continue;
    }
    if (aabb(hero, obj.el)){
      if (obj.kind==='item'){
        score += 50;
        obj.el.remove(); obstacles.delete(obj);
      }else{
        return gameOver();
      }
    }
  }
  requestAnimationFrame(loop);
}

function moveLeft(){ setLane(laneIdx-1); }
function moveRight(){ setLane(laneIdx+1); }

document.addEventListener('keydown', (e)=>{
  if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') moveLeft();
  if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') moveRight();
  if(e.key===' ' && !running && howto.hidden){ start(); }
});

let tx=null;
stage.addEventListener('touchstart', e=>{ tx = e.touches[0].clientX; }, {passive:true});
stage.addEventListener('touchmove',  e=>{
  if(tx==null) return;
  const dx = e.touches[0].clientX - tx;
  if(Math.abs(dx) > 40){
    (dx<0 ? moveLeft : moveRight)();
    tx = e.touches[0].clientX;
  }
},{passive:true});

function start(){
  howto.hidden = true;
  over.hidden = true;

  // ここで完全クリア（DOM + Set）
  stage.querySelectorAll('.obstacle, .item').forEach(el => el.remove());
  obstacles.clear();

  score = 0; speed = 220; spawnGap = 950; last = 0; lastSpawn = 0;
  setLane(1);
  hero.classList.add('walking');
  grid.style.animationPlayState = 'running';
  running = true;
  pauseBtn.textContent = '⏸ 一時停止';
  // requestAnimationFrame(loop) は呼ばない（多重起動防止）
}
function pause(){
  running = false;
  hero.classList.remove('walking');
  grid.style.animationPlayState = 'paused';
  pauseBtn.textContent = '▶︎ 再開';
}
function resume(){
  running = true;
  hero.classList.add('walking');
  grid.style.animationPlayState = 'running';
  pauseBtn.textContent = '⏸ 一時停止';
}
function gameOver(){
  running = false;
  hero.classList.remove('walking');
  grid.style.animationPlayState = 'paused';
  finalScore.textContent = Math.floor(score);
  if (score > best){ best = Math.floor(score); localStorage.setItem('runner_best', best); }
  finalBest.textContent = best;
  over.hidden = false;
}

// 「もう一度」はページリロードせず安全に再スタート
retry.addEventListener('click', (e)=>{
  e.preventDefault();
  start();
});

document.getElementById('startBtn').addEventListener('click', start);
document.getElementById('pauseBtn').addEventListener('click', ()=> running ? pause() : resume());

// ループは一度だけ起動
if(!rafStarted){
  rafStarted = true;
  requestAnimationFrame(loop);
}
</script>
</body>
</html>
