<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>シークレット挑戦 #66：Gravity Flip Tunnel（激むず・緩和版）</title>
  <!-- あれば使用（任意） -->
  <script src="../_unlock.js" defer></script>
  <style>
    :root{
      --bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;
      --accent:#a855f7;--ok:#22c55e;--warn:#ef4444;--muted:#9ca3af
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:900px;margin:24px auto;padding:16px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
    .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .btn{background:var(--accent);color:#1b0930;border:none;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
    .btn.ghost{background:#0ea5e9;color:#031423}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .muted{color:var(--muted);text-decoration:none}
    .stats{display:flex;gap:16px;align-items:center}
    .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
    canvas{
      display:block;width:100%;
      height:clamp(320px, calc(100svh - 260px), 640px);
      margin-top:10px;
      background:linear-gradient(#0f2238,#0b1626);
      border-radius:12px;border:1px solid #1a2740
    }
    @media (max-width:640px){ canvas{height:360px} }

    .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45)}
    .overlay .sheet{background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;display:grid;gap:10px;justify-items:center}
  </style>
</head>
<body>
<div class="wrap">
  <h1>シークレット挑戦 #66：Gravity Flip Tunnel（激むず）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">条件：<b>20秒生存</b> ＋ <b>オーブ12個</b></span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span>オーブ：<b id="orbs">0</b>/12</span>
      </div>
      <div class="row" style="gap:10px">
        <button class="btn" id="startBtn">START</button>
        <a class="muted" href="../../dex/index.html">← 図鑑へ戻る</a>
      </div>
    </div>

    <canvas id="cv"></canvas>

    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>

  <div class="muted" style="margin-top:8px">
    操作：タップ/クリック or <b>SPACE</b> で<strong>重力反転</strong>。フォーカスを外すと一時停止します。
  </div>
</div>

<script>
/* ========= アンロック ========= */
const DEX_KEY     = 'dex_state_v1';
const SECRET_NO   = 66;                 // 表示番号
const SECRET_ID   = 65;                 // 0-based id（#66 → 65）
const SECRET_FILE = 'secret_66.png';    // project-root に配置

function loadDex(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY)||'{}'); }catch{ return {}; } }
function saveDex(v){ localStorage.setItem(DEX_KEY, JSON.stringify(v||{})); }

function unlock66(){
  if (typeof window.unlockSecret === 'function'){ window.unlockSecret(SECRET_NO, SECRET_FILE); return; }
  if (typeof window.registerSecretFile === 'function'){ window.registerSecretFile(SECRET_ID, SECRET_FILE); }
  const dex = loadDex();
  dex.unlocked    = Object.assign({}, dex.unlocked, { [SECRET_ID]: true });
  dex.secretFiles = Object.assign({}, dex.secretFiles, { [String(SECRET_ID)]: SECRET_FILE });
  if (!dex.selected) dex.selected = SECRET_FILE;
  saveDex(dex);
  try{ window.dispatchEvent(new StorageEvent('storage', {key:DEX_KEY, newValue:JSON.stringify(dex)})); }catch(_){}
}

/* ========= Canvas 高DPI ========= */
const cv  = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', fitCanvas, {passive:true});
fitCanvas();

/* ========= DOM ========= */
const startBtn = document.getElementById('startBtn');
const timeEl   = document.getElementById('time');
const orbsEl   = document.getElementById('orbs');
const ov       = document.getElementById('ov');
const ovMsg    = document.getElementById('ovMsg');
const ovSub    = document.getElementById('ovSub');
const retryBtn = document.getElementById('retryBtn');

/* ========= 難易度ノブ（ここだけいじれば調整可） ========= */
const BORDER_H    = 36;
const PLAYER_W    = 22, PLAYER_H = 22;
const GRAVITY     = 900;
const FLIP_DAMP   = 0.60;   // 反転時の減速（↑で扱いやすく）
const START_SPD   = 300;    // ← 緩和
const END_SPD     = 520;    // ← 緩和
const TIME_NEED   = 20.0;   // ← 緩和（22→20）
const ORBS_NEED   = 12;     // ← 緩和（14→12）
const SPAWN_BASE  = 0.95;   // ← 緩和（密度↓）
const SPAWN_MIN   = 0.65;   // ← 緩和
const GAP_MAX     = 140;    // ← 緩和（広く）
const GAP_MIN     = 105;    // ← 緩和
const SAW_RATE    = 0.35;   // ← 緩和（ノコ少なめ）
const SAW_R       = 11;     // ← 緩和（やや小さく）
const HIT_FORGIVE = 4;      // ← 緩和（許容拡大）
const ORB_MAGNET  = 8;      // ← 取得を少し吸い寄せ

/* ========= 状態 ========= */
let playing=false, paused=false, t0=0, last=0, raf=0;
let px=90, py=0, vy=0, grav=+1;
let speed=START_SPD, spawnTimer=0, timeNow=0, orbCount=0;
let walls=[], saws=[], orbs=[];

function tunnelTop(){ return BORDER_H; }
function tunnelBot(){ return cv.clientHeight - BORDER_H; }

/* ========= リセット ========= */
function resetGame(){
  cancelAnimationFrame(raf);
  playing=false; paused=false;
  timeNow=0; orbCount=0; speed=START_SPD; spawnTimer=0;
  px=90; py=(tunnelTop()+tunnelBot())/2 - PLAYER_H/2; vy=0; grav=+1;
  walls.length=0; saws.length=0; orbs.length=0;
  timeEl.textContent='0.0'; orbsEl.textContent='0';
  ctx.clearRect(0,0,cv.clientWidth,cv.clientHeight);
  drawScene();
  ov.style.display='none';
}

/* ========= スポーン ========= */
function currentGap(){
  const k = Math.min(1, timeNow / TIME_NEED);
  return GAP_MAX + (GAP_MIN - GAP_MAX) * k;
}
function spawnPack(){
  const top = tunnelTop(), bot = tunnelBot(), H = bot - top;
  const gapH = currentGap();
  const gapY = top + (PLAYER_H*1.5) + Math.random()*(H - gapH - PLAYER_H*3);

  const w = 28 + Math.random()*18;
  const x = cv.clientWidth + 40;

  // 壁（上下）
  walls.push({x, y:top, w, h: Math.max(0, gapY - top)});
  walls.push({x, y:gapY + gapH, w, h: Math.max(0, bot - (gapY + gapH))});

  // オーブ（2個）
  orbs.push({x: x + w + 26, y: gapY + gapH/2 - 12, r: 7, taken:false});
  orbs.push({x: x + w + 52, y: gapY + gapH/2 + 12, r: 7, taken:false});

  // ノコ（35%で出現、上下振動）
  if (Math.random() < SAW_RATE){
    const sy = top + 20 + Math.random()*(H-40);
    saws.push({x: x + w + 120, y: sy, r: SAW_R, baseY: sy, amp: 26 + Math.random()*18, t:0});
  }
}

/* ========= 入力：重力反転 ========= */
function flip(){
  if (!playing || paused) return;
  grav *= -1;
  vy = -vy * FLIP_DAMP;
}
cv.addEventListener('pointerdown', flip, {passive:true});
window.addEventListener('keydown', (e)=>{ if (e.code==='Space'){ e.preventDefault(); flip(); }});
document.addEventListener('visibilitychange', ()=>{ if (playing) paused = document.hidden; });

/* ========= ループ ========= */
function loop(ts){
  if (!playing) return;
  if (!last) last = ts;
  const dt = (ts - last)/1000; last = ts;
  if (paused){ raf = requestAnimationFrame(loop); return; }

  timeNow = (ts - t0)/1000;
  timeEl.textContent = timeNow.toFixed(1);

  // スピード漸増
  const k = Math.min(1, timeNow / TIME_NEED);
  speed = START_SPD + (END_SPD - START_SPD) * k;

  // スポーン
  const spawnInt = Math.max(SPAWN_MIN, SPAWN_BASE - 0.02*timeNow);
  spawnTimer += dt; if (spawnTimer >= spawnInt){ spawnTimer = 0; spawnPack(); }

  // 縦物理
  vy += GRAVITY * grav * dt;
  py += vy * dt;

  const top = tunnelTop(), bot = tunnelBot();
  if (py < top){ py = top; vy = 0; }
  if (py + PLAYER_H > bot){ py = bot - PLAYER_H; vy = 0; }

  // 前進
  const vx = speed * dt;
  walls.forEach(o=> o.x -= vx);
  saws.forEach(s=>{ s.x -= vx; s.t += dt; s.y = s.baseY + Math.sin(s.t*4)*s.amp; });
  orbs.forEach(o=> o.x -= vx);

  // プレイヤー矩形
  const pr = {x:px, y:py, w:PLAYER_W, h:PLAYER_H};

  // オーブ取得（弱い磁力）
  for (const o of orbs){
    if (o.taken) continue;
    const dx = Math.abs(o.x - (pr.x + pr.w/2));
    const dy = Math.abs(o.y - (pr.y + pr.h/2));
    if (dx < (pr.w/2 + o.r + ORB_MAGNET) && dy < (pr.h/2 + o.r + ORB_MAGNET)){
      o.taken = true; orbCount++; orbsEl.textContent = orbCount;
    }
  }

  // 壁衝突
  for (const w of walls){
    if (w.x > pr.x + pr.w || w.x + w.w < pr.x) continue;
    const overlapX = !(pr.x + pr.w - HIT_FORGIVE < w.x || pr.x + HIT_FORGIVE > w.x + w.w);
    const overlapY = !(pr.y + pr.h - HIT_FORGIVE < w.y || pr.y + HIT_FORGIVE > w.y + w.h);
    if (overlapX && overlapY){ fail('壁に激突…'); return; }
  }

  // ノコ衝突（円と矩形の近接）
  for (const s of saws){
    const cx = Math.max(pr.x, Math.min(s.x, pr.x + pr.w));
    const cy = Math.max(pr.y, Math.min(s.y, pr.y + pr.h));
    const dx = s.x - cx, dy = s.y - cy;
    if (dx*dx + dy*dy < (s.r - HIT_FORGIVE)*(s.r - HIT_FORGIVE)){ fail('ノコギリに当たった…'); return; }
  }

  // 掃除
  walls = walls.filter(o=> o.x + o.w > -40);
  saws  = saws .filter(s=> s.x + s.r > -40);
  orbs  = orbs .filter(o=> !o.taken && o.x > -40);

  // 描画
  drawScene();

  // クリア条件
  if (timeNow >= TIME_NEED && orbCount >= ORBS_NEED){ success(); return; }

  raf = requestAnimationFrame(loop);
}

/* ========= 描画 ========= */
function drawScene(){
  const w = cv.clientWidth, h=cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0,'#0f2238'); grad.addColorStop(1,'#0b1626');
  ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

  ctx.fillStyle = '#0e243a';
  ctx.fillRect(0,0,w,BORDER_H);
  ctx.fillRect(0,h-BORDER_H,w,BORDER_H);

  ctx.fillStyle = '#ef4444';
  for (const o of walls){ ctx.fillRect(o.x,o.y,o.w,o.h); }

  for (const s of saws){
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate((performance.now()/220) % (Math.PI*2));
    ctx.fillStyle = '#ef4444';
    for(let i=0;i<8;i++){
      ctx.rotate(Math.PI/4);
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-s.r); ctx.lineTo(8,-s.r+6); ctx.closePath(); ctx.fill();
    }
    ctx.restore();
  }

  for (const o of orbs){
    ctx.beginPath(); ctx.arc(o.x,o.y,o.r,0,Math.PI*2); ctx.closePath();
    ctx.fillStyle = '#fbbf24'; ctx.fill();
    ctx.strokeStyle = '#fde68a'; ctx.lineWidth = 2; ctx.stroke();
  }

  ctx.fillStyle = (grav>0) ? '#22d3ee' : '#60a5fa';
  ctx.fillRect(px, py, PLAYER_W, PLAYER_H);

  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.beginPath(); ctx.moveTo(px+PLAYER_W/2, 0); ctx.lineTo(px+PLAYER_W/2, h); ctx.stroke();
}

/* ========= 成否 ========= */
function fail(msg){
  playing=false;
  ovMsg.textContent = '失敗…';
  ovSub.textContent = `${msg}（条件：${TIME_NEED}秒＆オーブ${ORBS_NEED}）`;
  ov.style.display = 'grid';
}
function success(){
  playing=false;
  unlock66();
  ovMsg.textContent = '解放成功！ #66 が使えるようになった';
  ovSub.textContent = '図鑑で選択できます。';
  ov.style.display = 'grid';
}

/* ========= 開始・再試行 ========= */
function start(){
  resetGame();
  playing=true; paused=false;
  t0 = performance.now(); last = t0;
  spawnTimer = 0.35;
  raf = requestAnimationFrame(loop);
}
startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);

/* 初期化 */
resetGame();
</script>
</body>
</html>
