<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>シークレット挑戦 #68：Rail Switcher（激むず）</title>
<style>
  :root{
    --bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;
    --accent:#0ea5e9;--warn:#ef4444;--ok:#22c55e;--muted:#9ca3af
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:900px;margin:24px auto;padding:16px}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
  .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .btn{background:var(--accent);color:#031423;border:none;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
  .btn.ghost{background:#f59e0b;color:#221a05}
  .muted{color:var(--muted);text-decoration:none}
  .stats{display:flex;gap:16px;align-items:center}
  .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
  canvas{
    display:block;width:100%;
    height:clamp(360px, calc(100svh - 260px), 640px);
    margin-top:10px;
    background:linear-gradient(#0f2238,#0b1626);
    border-radius:12px;border:1px solid #1a2740
  }
  @media (max-width:640px){ canvas{height:420px} }

  .overlay{
    position:absolute;inset:0;display:none;place-items:center;
    background:rgba(0,0,0,.45)
  }
  .overlay .sheet{
    background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;
    display:grid;gap:10px;justify-items:center
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>シークレット挑戦 #68：Rail Switcher（激むず）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">条件：鍵<b>3</b>個 → 扉へ到達</span>
        <span>鍵：<b id="keys">0</b>/3</span>
        <span>タイム：<b id="time">0.0</b>s（制限 45s）</span>
      </div>
      <div class="row" style="gap:10px; margin-right:16px">
        <button class="btn" id="startBtn">START</button>
        <a class="muted" href="../../dex/index.html">← 図鑑へ戻る</a>
      </div>
    </div>

    <canvas id="cv"></canvas>

    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>
  <div class="muted" style="margin-top:8px">
    操作：↑ / ↓ キー（モバイル：画面上半分タップ＝↑、下半分タップ＝↓）でレーン切替。  
    走行中は視界が徐々に狭くなります。ページスクロールは無効化してあります。
  </div>
</div>

<script>
/* ====== #68 解放ユーティリティ ====== */
const DEX_KEY = 'dex_state_v1';
const SECRET_ID = 67;                // 0始まり → #68
const SECRET_FILE = 'secret_68.png'; // project-root に置く

function loadDex(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY)||'{}'); }catch{ return {}; } }
function saveDex(v){ localStorage.setItem(DEX_KEY, JSON.stringify(v||{})); }
function unlockSecret68(){
  const dex = loadDex();
  dex.unlocked = Object.assign({}, dex.unlocked, { [SECRET_ID]: true });
  dex.secretFiles = dex.secretFiles || {};
  dex.secretFiles[String(SECRET_ID)] = SECRET_FILE;
  if (!dex.selected) dex.selected = SECRET_FILE;
  saveDex(dex);
  try{ window.dispatchEvent(new StorageEvent('storage', {key:DEX_KEY, newValue:JSON.stringify(dex)})); }catch(_){}
}

/* ====== Canvas（高DPI） ====== */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', fitCanvas, {passive:true});
fitCanvas();

/* ====== DOM ====== */
const startBtn = document.getElementById('startBtn');
const retryBtn = document.getElementById('retryBtn');
const timeEl = document.getElementById('time');
const keysEl = document.getElementById('keys');
const ov = document.getElementById('ov');
const ovMsg = document.getElementById('ovMsg');
const ovSub = document.getElementById('ovSub');

/* ====== ゲーム定数（激むず・ただし理不尽すぎない） ====== */
const LANES = 3;
const TIME_LIMIT = 45.0;                // 秒
const START_SPEED = 420;                // px/s
const END_SPEED   = 680;                // 30s で到達
const OBST_BASE   = 0.80;               // 障害物の基本湧き間隔（秒）
const OBST_MIN    = 0.46;               // 最短
const KEY_INT_MIN = 5.0, KEY_INT_MAX=7.0;
const PLAYER_X = 140;
const PLAYER_W = 42, PLAYER_H = 42;
const HIT_PAD  = 4;                     // 当たり判定ゆるめ
const DOOR_W   = 46, DOOR_H = 64;

/* 視界：プレイヤー中心の丸が徐々に縮む */
const VISION_R0 = 240;
const VISION_R1 = 140;                  // 最小半径（見えにくいが理不尽ではない）

/* ====== 状態 ====== */
let playing=false, t0=0, tPrev=0, raf=0, timeNow=0;
let laneY = []; // lane -> y
let lane = 1;   // 0,1,2
let speed = START_SPEED;
let obstTimer=0, keyTimer=0, nextKeyInt=6.0;
let obstacles = []; // {x,y,w,h}
let keys = [];      // {x,y,r,taken}
let door = null;    // {x,y,w,h,active}
let gotKeys = 0;

/* ====== レーンのY算出 ====== */
function computeLanes(){
  const h = cv.clientHeight;
  const top = Math.round(h*0.28);
  const gap = Math.round(h*0.18);
  laneY = [top, top+gap, top+gap*2];
}
computeLanes();

/* ====== 入力（上下・スクロール抑止） ====== */
function moveUp(){
  if (!playing) return;
  lane = Math.max(0, lane-1);
}
function moveDown(){
  if (!playing) return;
  lane = Math.min(LANES-1, lane+1);
}
cv.addEventListener('pointerdown', (e)=>{
  const rect = cv.getBoundingClientRect();
  const y = e.clientY - rect.top;
  (y < rect.height/2) ? moveUp() : moveDown();
}, {passive:true});

window.addEventListener('keydown', (e)=>{
  if (e.code === 'ArrowUp' || e.code === 'KeyW'){ e.preventDefault(); moveUp(); }
  if (e.code === 'ArrowDown' || e.code === 'KeyS'){ e.preventDefault(); moveDown(); }
}, {passive:false});

/* ====== リセット ====== */
function resetGame(){
  cancelAnimationFrame(raf);
  playing=false; timeNow=0; gotKeys=0;
  obstacles.length=0; keys.length=0; door=null;
  lane=1; speed=START_SPEED; obstTimer=0; keyTimer=0; nextKeyInt=rand(KEY_INT_MIN, KEY_INT_MAX);
  timeEl.textContent='0.0'; keysEl.textContent='0';
  ov.style.display='none';
  draw(0);
}

/* ====== ユーティリティ ====== */
function rand(a,b){ return a + Math.random()*(b-a); }
function rectsOverlap(a,b){
  return !(a.x+a.w-HIT_PAD < b.x || a.x+HIT_PAD > b.x+b.w || a.y+a.h-HIT_PAD < b.y || a.y+HIT_PAD > b.y+b.h);
}

/* ====== スポーン ====== */
function spawnObstacle(){
  // 1～2 レーンに配置（激むず：ときどき2連）
  const lanes = [0,1,2];
  shuffle(lanes);
  const n = Math.random()<0.35 ? 2 : 1;
  for(let i=0;i<n;i++){
    const L = lanes[i];
    const y = laneY[L]-PLAYER_H/2;
    const w = 60 + Math.random()*70;
    const h = 46;
    obstacles.push({x: cv.clientWidth+60 + i*40, y, w, h});
  }
}
function spawnKey(){
  const L = (Math.random()*LANES)|0;
  const y = laneY[L];
  keys.push({x: cv.clientWidth+80, y, r:14, taken:false});
}
function spawnDoor(){
  if (door) return;
  const L = (Math.random()*LANES)|0;
  const y = laneY[L]-DOOR_H/2;
  door = {x: cv.clientWidth+160, y, w:DOOR_W, h:DOOR_H, active:true};
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } }

/* ====== ループ ====== */
function loop(ts){
  if (!playing) return;
  if (!tPrev) tPrev = ts;
  const dt = (ts - tPrev)/1000;
  tPrev = ts;

  timeNow = (ts - t0)/1000;
  timeEl.textContent = timeNow.toFixed(1);

  // 難易度カーブ
  const k = Math.min(1, timeNow/30);
  speed = START_SPEED + (END_SPEED-START_SPEED)*k;

  obstTimer += dt;
  const obstInt = Math.max(OBST_MIN, OBST_BASE - 0.02*timeNow);
  if (obstTimer >= obstInt){
    obstTimer = 0;
    spawnObstacle();
  }

  keyTimer += dt;
  if (keyTimer >= nextKeyInt){
    keyTimer = 0;
    nextKeyInt = rand(KEY_INT_MIN, KEY_INT_MAX);
    spawnKey();
  }

  // 移動
  const vx = speed*dt;
  obstacles.forEach(o => o.x -= vx);
  keys.forEach(k => k.x -= vx);
  if (door) door.x -= vx;

  // 衝突
  const py = laneY[lane] - PLAYER_H/2;
  const player = {x:PLAYER_X, y:py, w:PLAYER_W, h:PLAYER_H};

  // 障害物
  for (const o of obstacles){
    if (rectsOverlap(player, o)){ return fail('障害物に衝突…'); }
  }

  // 鍵
  for (const k of keys){
    if (k.taken) continue;
    const box = {x:k.x-12, y:k.y-12, w:24, h:24};
    if (rectsOverlap(player, box)){
      k.taken = true;
      gotKeys++;
      keysEl.textContent = gotKeys;
      if (gotKeys >= 3){ spawnDoor(); }
    }
  }

  // 扉
  if (door && door.active){
    if (rectsOverlap(player, door)){
      return success();
    }
  }

  // 時間切れ
  if (timeNow >= TIME_LIMIT){ return fail('時間切れ…'); }

  // 画面外掃除
  obstacles = obstacles.filter(o => o.x + o.w > -40);
  keys      = keys.filter(k => !k.taken && k.x > -40);
  if (door && door.x + door.w <= -40){ door = null; /* 扉逃すとまた鍵→扉を狙ってね */ }

  draw(dt);
  raf = requestAnimationFrame(loop);
}

/* ====== 描画 ====== */
function draw(dt){
  const w = cv.clientWidth, h=cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景
  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0,'#0f2238'); grad.addColorStop(1,'#0b1626');
  ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

  // レーン補助線
  ctx.strokeStyle = 'rgba(255,255,255,.08)';
  laneY.forEach(y=>{
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
  });

  // 障害物
  ctx.fillStyle = '#ef4444';
  obstacles.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h));

  // 鍵
  keys.forEach(k=>{
    ctx.beginPath(); ctx.arc(k.x, k.y, 14, 0, Math.PI*2); ctx.fillStyle='#fbbf24'; ctx.fill();
    ctx.strokeStyle='#fde68a'; ctx.lineWidth=2; ctx.stroke();
  });

  // 扉
  if (door){
    ctx.fillStyle = gotKeys>=3 ? '#22c55e' : '#64748b';
    ctx.fillRect(door.x, door.y, door.w, door.h);
    ctx.fillStyle = 'rgba(0,0,0,.25)'; // 窓
    ctx.fillRect(door.x+10, door.y+10, 12, 18);
  }

  // プレイヤー
  const py = laneY[lane] - PLAYER_H/2;
  ctx.fillStyle = '#38bdf8';
  ctx.fillRect(PLAYER_X, py, PLAYER_W, PLAYER_H);

  // 視界マスク（外側を暗く）
  const t = timeNow||0;
  const r = VISION_R0 + (VISION_R1 - VISION_R0) * Math.min(1, t/30);
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,.60)';
  ctx.fillRect(0,0,w,h);
  const cx = PLAYER_X + PLAYER_W/2, cy = py + PLAYER_H/2;
  const g2 = ctx.createRadialGradient(cx, cy, Math.max(1,r*0.45), cx, cy, r);
  g2.addColorStop(0,'rgba(0,0,0,0)');
  g2.addColorStop(1,'rgba(0,0,0,.60)');
  ctx.globalCompositeOperation = 'destination-out';
  ctx.fillStyle = g2;
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* ====== 成否 ====== */
function fail(msg){
  playing=false;
  ovMsg.textContent = '失敗…';
  ovSub.textContent = msg + '（鍵3個 → 扉へ、制限45秒）';
  ov.style.display = 'grid';
}
function success(){
  playing=false;
  unlockSecret68();
  ovMsg.textContent = '解放成功！ #68 が使えるようになった';
  ovSub.textContent = '図鑑で選択できます。';
  ov.style.display = 'grid';
}

/* ====== 開始・再挑戦 ====== */
function start(){
  resetGame();
  playing=true;
  t0 = performance.now(); tPrev = t0;
  raf = requestAnimationFrame(loop);
}
startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);

/* タブ非表示で一時停止（復帰で再開） */
document.addEventListener('visibilitychange', ()=>{
  if (!playing) return;
  if (document.hidden){ cancelAnimationFrame(raf); }
  else { tPrev = performance.now(); raf = requestAnimationFrame(loop); }
});

/* 初期化 */
resetGame();
</script>
</body>
</html>
