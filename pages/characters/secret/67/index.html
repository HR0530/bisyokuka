<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>シークレット挑戦 #67：Phase Dash Corridor（激むず）</title>
  <!-- あれば使う（任意）：親フォルダに _unlock.js を置いている場合 -->
  <script src="../_unlock.js" defer></script>
  <style>
    :root{
      --bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;
      --accent:#06b6d4;--ok:#22c55e;--warn:#ef4444;--muted:#9ca3af
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:900px;margin:24px auto;padding:16px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
    .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .btn{background:var(--accent);color:#031a1f;border:none;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
    .btn.ghost{background:#0ea5e9;color:#031423}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .muted{color:var(--muted);text-decoration:none}
    .stats{display:flex;gap:16px;align-items:center}
    .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
    .controls{display:flex;gap:8px;align-items:center}
    .chip{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-size:12px}
    canvas{
      display:block;width:100%;
      height:clamp(320px, calc(100svh - 260px), 640px);
      margin-top:10px;
      background:linear-gradient(#0f2238,#0b1626);
      border-radius:12px;border:1px solid #1a2740
    }
    @media (max-width:640px){ canvas{height:360px} }
    .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45)}
    .overlay .sheet{background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;display:grid;gap:10px;justify-items:center}
  </style>
</head>
<body>
<div class="wrap">
  <h1>シークレット挑戦 #67：Phase Dash Corridor（激むず）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">条件：<b>20秒生存</b> ＋ <b>シャード10個</b></span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span>シャード：<b id="shards">0</b>/10</span>
        <span class="chip" id="phaseInfo">PHASE: Ready</span>
      </div>
      <div class="controls">
        <button class="btn" id="phaseBtn" aria-label="フェーズ">PHASE</button>
        <button class="btn" id="startBtn">START</button>
        <a class="muted" href="../../dex/index.html">← 図鑑へ戻る</a>
      </div>
    </div>

    <canvas id="cv"></canvas>

    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>

  <div class="muted" style="margin-top:8px;line-height:1.6">
    操作：タップ/クリック or <b>W/↑</b> で上昇（フラップ）。<br/>
    <b>PHASEボタン or SPACE長押し</b>でフェーズ（赤い壁をすり抜けられる／<b>紫ゾーン中はフェーズ中だと即死</b>）。<br/>
    フォーカスを外すと自動で一時停止します。
  </div>
</div>

<script>
/* ========= アンロック ========= */
const DEX_KEY     = 'dex_state_v1';
const SECRET_NO   = 67;                 // 表示番号
const SECRET_ID   = 66;                 // 0-based id（#67 → 66）
const SECRET_FILE = 'secret_67.png';    // project-root に配置

function loadDex(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY)||'{}'); }catch{ return {}; } }
function saveDex(v){ localStorage.setItem(DEX_KEY, JSON.stringify(v||{})); }
function unlock67(){
  if (typeof window.unlockSecret === 'function'){ window.unlockSecret(SECRET_NO, SECRET_FILE); return; }
  if (typeof window.registerSecretFile === 'function'){ window.registerSecretFile(SECRET_ID, SECRET_FILE); }
  const dex = loadDex();
  dex.unlocked    = Object.assign({}, dex.unlocked, { [SECRET_ID]: true });
  dex.secretFiles = Object.assign({}, dex.secretFiles, { [String(SECRET_ID)]: SECRET_FILE });
  if (!dex.selected) dex.selected = SECRET_FILE;
  saveDex(dex);
  try{ window.dispatchEvent(new StorageEvent('storage', {key:DEX_KEY, newValue:JSON.stringify(dex)})); }catch(_){}
}

/* ========= Canvas 高DPI ========= */
const cv  = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', fitCanvas, {passive:true});
fitCanvas();

/* ========= DOM ========= */
const startBtn  = document.getElementById('startBtn');
const phaseBtn  = document.getElementById('phaseBtn');
const timeEl    = document.getElementById('time');
const shardsEl  = document.getElementById('shards');
const phaseInfo = document.getElementById('phaseInfo');
const ov        = document.getElementById('ov');
const ovMsg     = document.getElementById('ovMsg');
const ovSub     = document.getElementById('ovSub');
const retryBtn  = document.getElementById('retryBtn');

/* ========= 難易度ノブ ========= */
const BORDER_H     = 36;
const PLAYER_W     = 22, PLAYER_H = 22;
const GRAVITY      = 980;          // 落下加速度
const THRUST_V     = -620;         // 押下で上昇
const START_SPD    = 300;          // スクロール開始
const END_SPD      = 520;          // 20s 時点
const TIME_NEED    = 20.0;         // 秒
const SHARDS_NEED  = 10;           // 個
const SPAWN_BASE   = 0.95;         // 出現間隔(秒)
const SPAWN_MIN    = 0.65;
const HIT_FORGIVE  = 3;
const GAP_MAX      = 150;          // コリドーGap（時間経過で縮小）
const GAP_MIN      = 105;

/* フェーズ（赤を無効化、紫はフェーズ中のみ致死） */
const PHASE_MAX    = 0.45;         // フェーズ連続最大秒
const PHASE_CD     = 0.85;         // クールダウン秒
let   phaseActive  = false;
let   phaseLeft    = PHASE_MAX;
let   phaseCDLeft  = 0;

/* ========= 状態 ========= */
let playing=false, paused=false, t0=0, last=0, raf=0;
let px=90, py=0, vy=0;
let speed=START_SPD, spawnTimer=0, timeNow=0, shardCount=0;
let walls=[], antiZones=[], shards=[];  // walls=赤, antiZones=紫

function topY(){ return BORDER_H; }
function botY(){ return cv.clientHeight - BORDER_H; }

/* ========= リセット ========= */
function resetGame(){
  cancelAnimationFrame(raf);
  playing=false; paused=false;
  timeNow=0; shardCount=0; speed=START_SPD; spawnTimer=0;
  phaseActive=false; phaseLeft=PHASE_MAX; phaseCDLeft=0;
  px=90; py=(topY()+botY())/2 - PLAYER_H/2; vy=0;
  walls.length=0; antiZones.length=0; shards.length=0;
  timeEl.textContent='0.0'; shardsEl.textContent='0';
  phaseInfo.textContent='PHASE: Ready';
  ctx.clearRect(0,0,cv.clientWidth,cv.clientHeight);
  drawScene();
  ov.style.display='none';
}

/* ========= スポーン ========= */
function currentGap(){
  const k = Math.min(1, timeNow / TIME_NEED);
  return GAP_MAX + (GAP_MIN - GAP_MAX) * k;
}
function spawnPack(){
  const top = topY(), bot = botY(), H = bot - top;
  const x = cv.clientWidth + 40;

  if (Math.random() < 0.55){
    // ① コリドー：上下壁で通路を作る（フラップ操作が主）
    const gapH = currentGap();
    const gapY = top + (PLAYER_H*1.6) + Math.random()*(H - gapH - PLAYER_H*3);
    const w = 28 + Math.random()*18;
    walls.push({x, y:top, w, h: Math.max(0, gapY - top)});                  // 上壁（赤：非フェーズ時のみ致死）
    walls.push({x, y:gapY + gapH, w, h: Math.max(0, bot - (gapY + gapH))}); // 下壁
    // 通路内にシャード
    shards.push({x: x + w + 36, y: gapY + gapH/2, r:7, taken:false});
    if (Math.random()<0.5) shards.push({x: x + w + 64, y: gapY + gapH/2 + (Math.random()<0.5?-14:14), r:7, taken:false});
  }else{
    // ② フェーズゲート：縦一枚壁→直後に紫ゾーン（フェーズ解除を強要）
    const gateH = H; // 全面
    const w = 18 + Math.random()*10;
    walls.push({x, y:top, w, h:gateH}); // 赤：フェーズ必須
    // 直後に紫（フェーズ中のみ致死）
    const azW = 38 + Math.random()*24;
    const azY = top + 24 + Math.random()*(H - 48 - 90);
    const azH = 90 + Math.random()*60;
    antiZones.push({x: x + w + 24, y: azY, w: azW, h: azH});
    // ご褒美シャード
    shards.push({x: x + w + 24 + azW + 28, y: azY + azH/2, r:7, taken:false});
  }
}

/* ========= 入力 ========= */
let flapHold=false;
function flap(){ vy = THRUST_V; }  // 1回分の上昇インパルス

// PC：W/↑ でフラップ
window.addEventListener('keydown', (e)=>{
  if (e.code==='ArrowUp' || e.code==='KeyW'){ e.preventDefault(); flap(); }
  if (e.code==='Space'){ e.preventDefault(); setPhase(true); }
});
window.addEventListener('keyup', (e)=>{
  if (e.code==='Space'){ e.preventDefault(); setPhase(false); }
});

// モバイル/マウス：キャンバス押下でフラップ
cv.addEventListener('pointerdown', ()=>{ flap(); }, {passive:true});

// 右上ボタンでフェーズ
phaseBtn.addEventListener('pointerdown', ()=> setPhase(true), {passive:true});
phaseBtn.addEventListener('pointerup',   ()=> setPhase(false), {passive:true});
phaseBtn.addEventListener('pointerleave',()=> setPhase(false), {passive:true});

function setPhase(on){
  if (!playing || paused) return;
  if (on){
    if (phaseCDLeft>0 || phaseLeft<=0) return; // 使えない
    phaseActive = true;
  }else{
    if (phaseActive){
      phaseActive = false;
      phaseCDLeft = PHASE_CD;  // 離したらクールダウン
    }
  }
}

/* タブ非表示で一時停止 */
document.addEventListener('visibilitychange', ()=>{ if (playing) paused = document.hidden; });

/* ========= ループ ========= */
function loop(ts){
  if (!playing) return;
  if (!last) last = ts;
  const dt = (ts - last)/1000; last = ts;
  if (paused){ raf = requestAnimationFrame(loop); return; }

  timeNow = (ts - t0)/1000; timeEl.textContent = timeNow.toFixed(1);

  // スピード漸増
  const k = Math.min(1, timeNow / TIME_NEED);
  speed = START_SPD + (END_SPD - START_SPD) * k;

  // スポーン
  const spawnInt = Math.max(SPAWN_MIN, SPAWN_BASE - 0.02*timeNow);
  spawnTimer += dt; if (spawnTimer >= spawnInt){ spawnTimer = 0; spawnPack(); }

  // フェーズ管理
  if (phaseActive){
    phaseLeft -= dt;
    if (phaseLeft <= 0){
      phaseLeft = 0;
      phaseActive = false;
      phaseCDLeft = PHASE_CD;
    }
  }else{
    if (phaseCDLeft > 0){
      phaseCDLeft -= dt;
      if (phaseCDLeft <= 0){
        phaseCDLeft = 0;
        phaseLeft = PHASE_MAX; // CD終了で一気に回復（テンポ良く）
      }
    }
  }
  phaseInfo.textContent = phaseActive
    ? `PHASE: ${phaseLeft.toFixed(2)}s`
    : (phaseCDLeft>0 ? `CD: ${phaseCDLeft.toFixed(2)}s` : 'PHASE: Ready');

  // 縦物理（フラップ式）
  vy += GRAVITY * dt;
  py += vy * dt;
  const top = topY(), bot = botY();
  if (py < top){ py = top; vy = 0; }
  if (py + PLAYER_H > bot){ py = bot - PLAYER_H; vy = 0; }

  // 前進
  const vx = speed * dt;
  walls.forEach(o=> o.x -= vx);
  antiZones.forEach(a=> a.x -= vx);
  shards.forEach(s=> s.x -= vx);

  // プレイヤー当たり
  const pr = {x:px, y:py, w:PLAYER_W, h:PLAYER_H};

  // 赤壁：非フェーズ中のみ致死
  for (const w of walls){
    if (w.x > pr.x + pr.w || w.x + w.w < pr.x) continue;
    const overlapX = !(pr.x + pr.w - HIT_FORGIVE < w.x || pr.x + HIT_FORGIVE > w.x + w.w);
    const overlapY = !(pr.y + pr.h - HIT_FORGIVE < w.y || pr.y + HIT_FORGIVE > w.y + w.h);
    if (overlapX && overlapY && !phaseActive){ fail('赤壁に衝突…（フェーズで通過）'); return; }
  }
  // 紫ゾーン：フェーズ中のみ致死
  for (const a of antiZones){
    if (a.x > pr.x + pr.w || a.x + a.w < pr.x) continue;
    const overlapX = !(pr.x + pr.w - HIT_FORGIVE < a.x || pr.x + HIT_FORGIVE > a.x + a.w);
    const overlapY = !(pr.y + pr.h - HIT_FORGIVE < a.y || pr.y + HIT_FORGIVE > a.y + a.h);
    if (overlapX && overlapY && phaseActive){ fail('紫域でフェーズ中…（解除して回避）'); return; }
  }

  // シャード回収（弱磁力）
  for (const s of shards){
    if (s.taken) continue;
    const dx = Math.abs(s.x - (pr.x + pr.w/2));
    const dy = Math.abs(s.y - (pr.y + pr.h/2));
    if (dx < pr.w/2 + s.r + 6 && dy < pr.h/2 + s.r + 6){
      s.taken = true; shardCount++; shardsEl.textContent = shardCount;
    }
  }

  // 掃除
  walls     = walls.filter(o=> o.x + o.w > -40);
  antiZones = antiZones.filter(a=> a.x + a.w > -40);
  shards    = shards.filter(s=> !s.taken && s.x > -40);

  // 描画
  drawScene();

  // クリア判定
  if (timeNow >= TIME_NEED && shardCount >= SHARDS_NEED){ success(); return; }

  raf = requestAnimationFrame(loop);
}

/* ========= 描画 ========= */
function drawScene(){
  const w = cv.clientWidth, h=cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景
  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0,'#0f2238'); grad.addColorStop(1,'#0b1626');
  ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

  // トンネル境界
  ctx.fillStyle = '#0e243a';
  ctx.fillRect(0,0,w,BORDER_H);
  ctx.fillRect(0,h-BORDER_H,w,BORDER_H);

  // 紫ゾーン
  ctx.fillStyle = '#7c3aed';
  antiZones.forEach(a=> ctx.fillRect(a.x,a.y,a.w,a.h));

  // 赤壁
  ctx.fillStyle = '#ef4444';
  walls.forEach(o=> ctx.fillRect(o.x,o.y,o.w,o.h));

  // シャード
  for (const s of shards){
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.closePath();
    ctx.fillStyle = '#fbbf24'; ctx.fill();
    ctx.strokeStyle = '#fde68a'; ctx.lineWidth = 2; ctx.stroke();
  }

  // プレイヤー
  ctx.fillStyle = phaseActive ? '#06b6d4' : '#22d3ee';
  ctx.fillRect(px, py, PLAYER_W, PLAYER_H);

  // ガイド線
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.beginPath(); ctx.moveTo(px+PLAYER_W/2, 0); ctx.lineTo(px+PLAYER_W/2, h); ctx.stroke();
}

/* ========= 成否 ========= */
function fail(msg){
  playing=false;
  ovMsg.textContent = '失敗…';
  ovSub.textContent = `${msg}（条件：${TIME_NEED.toFixed(0)}秒＆シャード${SHARDS_NEED}）`;
  ov.style.display = 'grid';
}
function success(){
  playing=false;
  unlock67();
  ovMsg.textContent = '解放成功！ #67 が使えるようになった';
  ovSub.textContent = '図鑑で選択できます。';
  ov.style.display = 'grid';
}

/* ========= 開始・再試行 ========= */
function start(){
  resetGame();
  playing=true; paused=false;
  t0 = performance.now(); last = t0;
  spawnTimer = 0.35; // はじめ少し余白
  raf = requestAnimationFrame(loop);
}
startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);

/* 初期化 */
resetGame();
</script>
</body>
</html>
