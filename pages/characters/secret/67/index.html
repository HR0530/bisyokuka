<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- _unlock.js がある場合はそれを使い、無い場合は下のフォールバックが効きます -->
  <script src="../_unlock.js"></script>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Secret #67：タワースタック</title>
  <style>
    :root{--bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;--accent:#f59e0b;--muted:#9ca3af}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:900px;margin:24px auto;padding:16px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
    .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .stats{display:flex;gap:14px;align-items:center}
    .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
    .btn{background:var(--accent);color:#221a05;border:none;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
    .btn.ghost{background:#0ea5e9;color:#031423}
    .muted{color:var(--muted);text-decoration:none}
    canvas{
      display:block;width:100%;
      height:clamp(360px, calc(100svh - 260px), 720px);
      margin-top:10px;border-radius:12px;border:1px solid #1a2740;
      background:linear-gradient(#0f2238,#0b1626)
    }
    .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45)}
    .overlay .sheet{background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;
      display:grid;gap:10px;justify-items:center}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Secret #67：タワースタック（激むず）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">条件：<b id="targetLbl">12段到達</b></span>
        <span>段数：<b id="layerNow">0</b>/<b id="layerMax">12</b></span>
        <span>ベスト：<b id="bestLbl">0</b>段</span>
      </div>
      <div class="row">
        <button class="btn" id="startBtn">START</button>
        <a class="muted" href="../../dex/index.html">← 図鑑へ</a>
      </div>
    </div>
    <canvas id="cv"></canvas>

    <!-- 成功/失敗オーバーレイ -->
    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div id="ovSub" class="muted"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>
  <div class="muted" style="margin-top:8px">
    操作：クリック/タップ または <b>SPACE</b> で落下。<br/>
    「PERFECT!」で少し幅が回復。フォーカスが外れると一時停止します。
  </div>
</div>

<script>
/* ===== Secret解放ユーティリティ（_unlock.js が無くても動くフォールバック） ===== */
(function ensureGrant(){
  if (window.SecretDex && typeof window.SecretDex.grant==='function') return;
  window.SecretDex = {
    grant(no){
      const DEX_KEY='dex_state_v1', id=no-1, file=`secret_${no}.png`;
      let dex={}; try{dex=JSON.parse(localStorage.getItem(DEX_KEY)||'{}')}catch{}
      dex.unlocked=dex.unlocked||{}; dex.secretFiles=dex.secretFiles||{};
      dex.unlocked[id]=true; dex.secretFiles[String(id)]=file;
      if(!dex.selected) dex.selected=file;
      localStorage.setItem(DEX_KEY, JSON.stringify(dex));
      try{window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)}));}catch(_){}
    }
  };
})();

/* ===== Canvas 高DPI対応 ===== */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', fitCanvas, {passive:true}); fitCanvas();

/* ===== UI要素 ===== */
const startBtn = document.getElementById('startBtn');
const retryBtn = document.getElementById('retryBtn');
const ov = document.getElementById('ov');
const ovMsg = document.getElementById('ovMsg');
const ovSub = document.getElementById('ovSub');
const layerNowEl = document.getElementById('layerNow');
const layerMaxEl = document.getElementById('layerMax');
const targetLbl = document.getElementById('targetLbl');
const bestLbl = document.getElementById('bestLbl');

/* ===== 難易度ノブ（必要ならここだけ変える） ===== */
const TARGET_LAYERS = 12;      // クリアに必要な段数（下段基準で+12枚）
const INIT_WIDTH    = 160;     // 初期ブロック幅(px)
const BLOCK_H       = 18;      // ブロック高さ
const SPEED0        = 150;     // 往復速度の初期値(px/s)
const SPEED_STEP    = 12;      // 1段ごと加速
const FORGIVE       = 3;       // 当たり許容（px）→少し重なっていればOK
const PERFECT_T     = 3;       // PERFECT判定（中心ズレpx 以下）
const PERFECT_BONUS = 6;       // PERFECTで幅回復（px）
const MIN_FAIL_W    = 6;       // これ未満の重なりは失敗扱い
const CAMERA_PAD    = 80;      // 上マージン（カメラ追従）
const WIND          = 0;       // 風（0で無効、±px/s で横流れ）

/* ===== 状態 ===== */
let playing=false, raf=0, time=0, last=0, best=0;
try{ best = +(localStorage.getItem('secret67_best')||0); }catch{}
bestLbl.textContent = best;

let layers=[];   // {x,y,w,h,color}
let scraps=[];   // 落ちるハミ出し破片
let mover=null;  // 動いている現在のブロック
let camY=0;      // カメラオフセット

/* ===== ユーティリティ ===== */
function rand(a,b){ return a + Math.random()*(b-a); }
function groundY(){ return cv.clientHeight - 40; }  // 地面のY

function blockColor(i){
  // 下から上へ少し明るく
  const t = Math.min(1, i/(TARGET_LAYERS+2));
  const r = Math.floor(230 - 80*t), g = Math.floor(200 - 100*t), b = 90+Math.floor(30*t);
  return `rgb(${r},${g},${b})`;
}

/* ===== セットアップ ===== */
function reset(){
  cancelAnimationFrame(raf);
  playing=false; time=0; last=0; camY=0; layers.length=0; scraps.length=0; mover=null;
  layerNowEl.textContent = '0';
  layerMaxEl.textContent = String(TARGET_LAYERS);
  targetLbl.textContent = `${TARGET_LAYERS}段到達`;
  ov.style.display = 'none';
  // 台座
  const baseW = Math.min(INIT_WIDTH*1.2, cv.clientWidth*0.9);
  const gx = (cv.clientWidth - baseW)/2;
  const gy = groundY() - BLOCK_H;
  layers.push({x:gx, y:gy, w:baseW, h:BLOCK_H, color:blockColor(0)});
  spawnMover(1);
  draw(0);
}

function spawnMover(layerIndex){
  const prev = layers[layers.length-1];
  const w = layerIndex===1 ? INIT_WIDTH : prev.w; // 2段目＝最初の可動ブロックは初期幅
  const y = prev.y - BLOCK_H;
  const dir = Math.random() < 0.5 ? 1 : -1;
  const speed = SPEED0 + SPEED_STEP*(layerIndex-1);
  let x = dir>0 ? -w : cv.clientWidth;
  const color = blockColor(layerIndex);
  mover = {x, y, w, h:BLOCK_H, vx: dir*speed, color, layerIndex};
}

/* ===== 操作（落下） ===== */
function drop(){
  if(!playing || !mover) return;
  // 重なり計算
  const prev = layers[layers.length-1];
  const left = Math.max(mover.x, prev.x);
  const right= Math.min(mover.x + mover.w, prev.x + prev.w);
  let overlap = right - left;

  // 風で流された場合の微補正
  overlap += 0; // 現在は無し（必要ならここで補正）

  if (overlap <= 0 || overlap < MIN_FAIL_W){
    // 失敗：はみ出し全落下
    scraps.push({x:mover.x, y:mover.y, w:mover.w, h:mover.h, vy:60});
    mover = null;
    fail('重なりが無くて落ちた…');
    return;
  }

  // PERFECT判定（中心のズレ）
  const c1 = mover.x + mover.w/2;
  const c0 = prev.x + prev.w/2;
  const perfect = Math.abs(c1 - c0) <= PERFECT_T;

  // はみ出した左右の破片を落下
  const leftCut  = Math.max(0, left - mover.x);
  const rightCut = Math.max(0, (mover.x + mover.w) - (left + overlap));
  if(leftCut > 0) scraps.push({x:mover.x, y:mover.y, w:leftCut, h:BLOCK_H, vy:80});
  if(rightCut> 0) scraps.push({x:left+overlap, y:mover.y, w:rightCut, h:BLOCK_H, vy:80});

  // 新しい静止ブロック（少し甘めの許容量 FORGIVE を足しておく）
  const newW = Math.min(prev.w + (perfect?PERFECT_BONUS:0), Math.max(overlap + FORGIVE, overlap));
  const newX = left - Math.max(0, (FORGIVE/2));
  layers.push({x:newX, y:mover.y, w:newW, h:BLOCK_H, color:mover.color});
  mover = null;

  // 進捗
  const placed = layers.length - 1; // 台座を除く
  layerNowEl.textContent = String(placed);
  if (placed > best){ best = placed; localStorage.setItem('secret67_best', String(best)); bestLbl.textContent = best; }

  // 勝利判定
  if (placed >= TARGET_LAYERS){
    success();
    return;
  }

  // 次のブロック
  spawnMover(placed+1);
}

/* ===== ループ ===== */
function start(){
  if (playing) return;
  reset();
  playing = true;
  last = performance.now();
  raf = requestAnimationFrame(loop);
}
function loop(ts){
  if(!playing) return;
  const dt = Math.min(0.033, (ts - last)/1000); // 安全のため最大フレーム時間制限
  last = ts;
  time += dt;

  update(dt);
  draw(dt);

  raf = requestAnimationFrame(loop);
}

/* ===== 更新 ===== */
let perfectFlash=0; // PERFECT演出タイマー
function update(dt){
  // mover移動
  if(mover){
    mover.x += mover.vx*dt + WIND*dt;
    // 端で反転
    if (mover.x <= -mover.w){ mover.x = -mover.w; mover.vx = Math.abs(mover.vx); }
    if (mover.x + mover.w >= cv.clientWidth + mover.w){ mover.x = cv.clientWidth + mover.w - mover.w; mover.vx = -Math.abs(mover.vx); }
  }

  // スクラップ落下
  for(const s of scraps){ s.y += s.vy*dt; s.vy += 240*dt; }
  scraps = scraps.filter(s=> s.y < cv.clientHeight + 60);

  // カメラ（塔のトップが上に来たら追従）
  const topY = layers[layers.length-1].y;
  const tgtCam = Math.max(0, CAMERA_PAD - topY);
  camY += (tgtCam - camY) * Math.min(1, dt*3);

  // PERFECT 演出減衰
  perfectFlash = Math.max(0, perfectFlash - dt);
}

/* ===== 描画 ===== */
function draw(dt){
  const w=cv.clientWidth, h=cv.clientHeight;
  // 背景
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#0f2238'); g.addColorStop(1,'#0b1626');
  ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

  ctx.save();
  ctx.translate(0, camY);

  // 地面
  ctx.fillStyle = '#0e243a';
  ctx.fillRect(0, groundY(), w, 40);

  // 既存ブロック
  for (let i=0;i<layers.length;i++){
    const b = layers[i];
    ctx.fillStyle = b.color;
    ctx.fillRect(Math.round(b.x), Math.round(b.y), Math.round(b.w), b.h);
  }

  // mover
  if(mover){
    ctx.fillStyle = mover.color;
    ctx.fillRect(Math.round(mover.x), Math.round(mover.y), Math.round(mover.w), mover.h);
  }

  // スクラップ
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = '#d97706';
  for(const s of scraps){
    ctx.fillRect(Math.round(s.x), Math.round(s.y), Math.round(s.w), s.h);
  }
  ctx.globalAlpha = 1;

  // PERFECT演出
  if (perfectFlash > 0){
    const b = layers[layers.length-1];
    ctx.strokeStyle = `rgba(255,255,255,${perfectFlash})`;
    ctx.lineWidth = 2;
    ctx.strokeRect(b.x-4, b.y-4, b.w+8, b.h+8);
  }

  ctx.restore();

  // ガイド
  ctx.strokeStyle = 'rgba(255,255,255,.06)';
  ctx.beginPath(); ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h); ctx.stroke();
}

/* ===== 成否表示 ===== */
function success(){
  playing=false;
  SecretDex.grant(67);
  ovMsg.textContent = '解放成功！';
  ovSub.textContent = '#67 が使えるようになりました。';
  ov.style.display = 'grid';
}
function fail(msg){
  playing=false;
  ovMsg.textContent = '失敗…';
  ovSub.textContent = msg || 'ずれて落ちました。';
  ov.style.display = 'grid';
}

/* ===== 入力 ===== */
function onPress(e){ e && e.preventDefault(); if(!playing){ start(); return; } drop(); }
cv.addEventListener('pointerdown', onPress, {passive:false});
addEventListener('keydown', (e)=>{ if(e.code==='Space'){ onPress(e); }});

document.addEventListener('visibilitychange', ()=>{ if(document.hidden) playing=false; });

startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);

/* 初期描画 */
reset();
</script>
</body>
</html>
