<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- _unlock.js があれば先に読み込み。無くても下のフォールバックで解放されます -->
  <script src="../_unlock.js"></script>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Secret #67：ペンデュラム・ウィンドタワー</title>
  <style>
    :root{--bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;--accent:#f59e0b;--muted:#9ca3af}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:900px;margin:24px auto;padding:16px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
    .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .stats{display:flex;gap:14px;align-items:center}
    .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
    .btn{background:var(--accent);color:#221a05;border:none;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
    .btn.ghost{background:#0ea5e9;color:#031423}
    .muted{color:var(--muted);text-decoration:none}
    canvas{
      display:block;width:100%;
      height:clamp(360px, calc(100svh - 260px), 720px);
      margin-top:10px;border-radius:12px;border:1px solid #1a2740;
      background:linear-gradient(#0f2238,#0b1626)
    }
    .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45)}
    .overlay .sheet{background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;
      display:grid;gap:10px;justify-items:center}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Secret #67：ペンデュラム・ウィンドタワー（激むず）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">条件：<b id="targetLbl">18段到達</b></span>
        <span>段数：<b id="layerNow">0</b>/<b id="layerMax">18</b></span>
        <span>風：<b id="windLbl">なし</b></span>
        <span>ベスト：<b id="bestLbl">0</b>段</span>
      </div>
      <div class="row">
        <button class="btn" id="startBtn">START</button>
        <a class="muted" href="../../dex/index.html">← 図鑑へ</a>
      </div>
    </div>
    <canvas id="cv"></canvas>

    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div id="ovSub" class="muted"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>
  <div class="muted" style="margin-top:8px">
    操作：クリック/タップ または <b>SPACE</b> で「リリース」（その時点の振り子の慣性＋風が落下に乗ります）。<br/>
    PERFECT で幅が少し回復。フォーカスが外れると一時停止します。
  </div>
</div>

<script>
/* ===== Secret解放フォールバック ===== */
(function ensureGrant(){
  if (window.SecretDex && typeof window.SecretDex.grant==='function') return;
  window.SecretDex = {
    grant(no){
      const DEX_KEY='dex_state_v1', id=no-1, file=`secret_${no}.png`;
      let dex={}; try{dex=JSON.parse(localStorage.getItem(DEX_KEY)||'{}')}catch{}
      dex.unlocked=dex.unlocked||{}; dex.secretFiles=dex.secretFiles||{};
      dex.unlocked[id]=true; dex.secretFiles[String(id)]=file;
      if(!dex.selected) dex.selected=file;
      localStorage.setItem(DEX_KEY, JSON.stringify(dex));
      try{window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)}));}catch(_){}
    }
  };
})();

/* ===== Canvas DPI ===== */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', fitCanvas, {passive:true}); fitCanvas();

/* ===== UI ===== */
const startBtn = document.getElementById('startBtn');
const retryBtn = document.getElementById('retryBtn');
const ov = document.getElementById('ov');
const ovMsg = document.getElementById('ovMsg');
const ovSub = document.getElementById('ovSub');
const layerNowEl = document.getElementById('layerNow');
const layerMaxEl = document.getElementById('layerMax');
const targetLbl = document.getElementById('targetLbl');
const bestLbl = document.getElementById('bestLbl');
const windLbl = document.getElementById('windLbl');

/* ===== 難易度ノブ ===== */
const TARGET_LAYERS = 18;     // ← ここを 16 とかに下げると楽になる
const INIT_WIDTH    = 120;
const BLOCK_H       = 18;
const PERFECT_T     = 2.5;    // ピクセル以内で PERFECT
const PERFECT_BONUS = 5;      // PERFECT の回復幅
const FORGIVE       = 2;      // 最終重なりに甘め補正
const MIN_FAIL_W    = 5;      // これ未満はアウト

// 振り子（スイング）系
const SWING_SPEED0  = 1.2;    // 初期角速度（rad/s）
const SWING_SPD_STEP= 0.08;   // 段ごと加速
const SWING_AMP0    = 0.70;   // 角度振幅（rad）初期値（約40°）
const SWING_AMP_STEP= 0.015;  // 段ごと拡大
const ARM_LEN_FRAC  = 0.42;   // アーム長（画面高に対する比）

// 落下＆風
const GRAVITY       = 1350;   // px/s^2
const GUST_PROB     = 0.45;   // 突風発生確率
const GUST_MIN      = 120;    // 風速下限（px/s）
const GUST_MAX      = 220;    // 風速上限
const GUST_TIME     = 0.55;   // 風が持続する秒数

/* ===== 状態 ===== */
let playing=false, raf=0, last=0, t=0, best=0;
try{ best = +(localStorage.getItem('secret67_best')||0); }catch{}
bestLbl.textContent = best;

let layers=[];  // 静止ブロック
let scraps=[];  // 落下破片
let camY=0;

let swingT=0, swingAmp=SWING_AMP0, swingSpd=SWING_SPEED0, armLen=0;
let carrierY=0, carrierX=0, carrierVX=0;
let falling=null;  // {x,y,w,h,vx,vy,active}
let pendingWidth=INIT_WIDTH;

/* 風イベント */
let gustVX=0, gustTimer=0;
function maybeGust(){
  if (Math.random() < GUST_PROB){
    gustVX = (Math.random()<0.5? -1:1) * (GUST_MIN + Math.random()*(GUST_MAX-GUST_MIN));
    gustTimer = GUST_TIME;
    windLbl.textContent = (gustVX>0?'→':'←') + Math.abs(Math.round(gustVX)) + 'px/s';
  }else{
    gustVX = 0; gustTimer = 0;
    windLbl.textContent = 'なし';
  }
}

/* ===== セットアップ ===== */
function groundY(){ return cv.clientHeight - 40; }

function reset(){
  cancelAnimationFrame(raf);
  playing=false; t=0; last=0; camY=0; scraps.length=0; layers.length=0;
  pendingWidth=INIT_WIDTH;
  swingT=0; swingAmp=SWING_AMP0; swingSpd=SWING_SPEED0;
  armLen = Math.max(160, cv.clientHeight * ARM_LEN_FRAC);
  // 台座
  const baseW = Math.min(INIT_WIDTH*1.2, cv.clientWidth*0.9);
  const gx = (cv.clientWidth - baseW)/2;
  const gy = groundY() - BLOCK_H;
  layers.push({x:gx, y:gy, w:baseW, h:BLOCK_H, color:'#e8cc66'});
  // 初期キャリア位置
  carrierY = gy - armLen - 60;
  swingT = 0;
  updateCarrier(0);
  // UI
  layerNowEl.textContent = '0';
  layerMaxEl.textContent = String(TARGET_LAYERS);
  targetLbl.textContent = `${TARGET_LAYERS}段到達`;
  windLbl.textContent = 'なし';
  ov.style.display = 'none';
  draw(0);
}

function updateCarrier(dt){
  // 振り子の位相を進め、アーム先の X を算出
  swingT += dt * swingSpd;
  const ang = Math.sin(swingT) * swingAmp;       // -amp..+amp
  const cx = cv.clientWidth/2;
  carrierX = cx + Math.sin(ang) * armLen;        // 水平位置
  carrierVX = Math.cos(swingT) * swingAmp * swingSpd * armLen * Math.cos(ang); // 近似
}

/* ===== ドロップ（落下開始） ===== */
function release(){
  if (!playing || falling) return;
  // 風抽選（このドロップ中のみ）
  maybeGust();
  // 今のキャリア位置＆慣性を移す
  falling = {
    x: carrierX - pendingWidth/2,
    y: carrierY,
    w: pendingWidth,
    h: BLOCK_H,
    vx: carrierVX,     // 慣性
    vy: 0,
    color: '#f5d76b',
    active: true
  };
}

/* ===== 1段確定処理 ===== */
const PERFECT_FLASH = {t:0};
function settleOne(){
  const top = layers[layers.length-1];
  const f = falling; if(!f) return;

  // オーバーラップ
  const left = Math.max(f.x, top.x);
  const right= Math.min(f.x + f.w, top.x + top.w);
  const overlap = right - left;

  if (overlap <= 0 || overlap < MIN_FAIL_W){
    // 全落下
    scraps.push({x:f.x, y:f.y, w:f.w, h:f.h, vy:80});
    falling=null;
    fail('重なりが足りず落下…');
    return;
  }

  // PERFECT 判定（中心ズレ）
  const c1 = f.x + f.w/2;
  const c0 = top.x + top.w/2;
  const perfect = Math.abs(c1 - c0) <= PERFECT_T;

  // はみ出し落下
  const leftCut  = Math.max(0, left - f.x);
  const rightCut = Math.max(0, (f.x + f.w) - (left + overlap));
  if(leftCut  > 0) scraps.push({x:f.x,           y:f.y, w:leftCut,  h:f.h, vy:100});
  if(rightCut > 0) scraps.push({x:left+overlap,  y:f.y, w:rightCut, h:f.h, vy:100});

  // 次のトップ
  const newW = Math.min(top.w + (perfect?PERFECT_BONUS:0), Math.max(overlap + FORGIVE, overlap));
  layers.push({x:left - Math.max(0, FORGIVE/2), y:f.y, w:newW, h:f.h, color:'#ffd86b'});
  pendingWidth = newW;
  falling = null;

  // PERFECT演出
  if (perfect) PERFECT_FLASH.t = 0.4;

  // 進捗＆難化
  const placed = layers.length - 1;
  layerNowEl.textContent = placed;
  if (placed > best){ best=placed; localStorage.setItem('secret67_best', String(best)); bestLbl.textContent = best; }
  swingSpd += SWING_SPD_STEP;
  swingAmp = Math.min(1.05, swingAmp + SWING_AMP_STEP); // 最大~60度くらい

  // クリア
  if (placed >= TARGET_LAYERS){ success(); return; }
}

/* ===== ループ ===== */
function start(){
  if (playing) return;
  reset(); playing=true;
  last = performance.now();
  raf = requestAnimationFrame(loop);
}
function loop(ts){
  if (!playing) return;
  const dt = Math.min(0.033, (ts - last)/1000); last = ts; t += dt;

  // キャリア更新（振り子）
  updateCarrier(dt);

  // 落下中
  if (falling){
    // 風
    if (gustTimer > 0){
      gustTimer -= dt; if (gustTimer <= 0){ gustVX = 0; windLbl.textContent = 'なし'; }
    }
    falling.vx += (gustVX ? 0 : 0); // 風は等速なのでここでは加速しない
    const totalVX = falling.vx + gustVX;

    falling.x += totalVX * dt;
    falling.vy += GRAVITY * dt;
    falling.y += falling.vy * dt;

    // 着地判定（トップの上）
    const top = layers[layers.length-1];
    const targetY = top.y - falling.h;
    if (falling.y >= targetY){
      falling.y = targetY;
      settleOne();
    }
  }

  // 破片
  for(const s of scraps){ s.y += s.vy*dt; s.vy += 250*dt; }
  scraps = scraps.filter(s=> s.y < cv.clientHeight + 60);

  // カメラ追従
  const topY = layers[layers.length-1].y;
  const tgtCam = Math.max(0, 80 - topY);
  camY += (tgtCam - camY) * Math.min(1, dt*3);

  // PERFECT エフェクト
  PERFECT_FLASH.t = Math.max(0, PERFECT_FLASH.t - dt);

  draw(dt);
  raf = requestAnimationFrame(loop);
}

/* ===== 描画 ===== */
function draw(dt){
  const w=cv.clientWidth, h=cv.clientHeight;
  // 背景
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#0f2238'); g.addColorStop(1,'#0b1626');
  ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

  ctx.save();
  ctx.translate(0, camY);

  // 地面
  ctx.fillStyle = '#0e243a';
  ctx.fillRect(0, groundY(), w, 40);

  // キャリア（クレーン）
  ctx.strokeStyle = '#7dd3fc';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(w/2, 20); ctx.lineTo(w/2, groundY()-armLen-60); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(w/2, groundY()-armLen-60); ctx.lineTo(carrierX, carrierY); ctx.stroke();
  ctx.fillStyle = '#7dd3fc';
  ctx.fillRect(carrierX-2, carrierY-2, 4, 4);

  // 静止ブロック
  for (let i=0;i<layers.length;i++){
    const b = layers[i];
    ctx.fillStyle = b.color;
    ctx.fillRect(Math.round(b.x), Math.round(b.y), Math.round(b.w), b.h);
  }

  // 落下ブロック
  if (falling){
    ctx.fillStyle = falling.color;
    ctx.fillRect(Math.round(falling.x), Math.round(falling.y), Math.round(falling.w), falling.h);
  }

  // 破片
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = '#d97706';
  for(const s of scraps){
    ctx.fillRect(Math.round(s.x), Math.round(s.y), Math.round(s.w), s.h);
  }
  ctx.globalAlpha = 1;

  // PERFECT枠
  if (PERFECT_FLASH.t > 0){
    const b = layers[layers.length-1];
    ctx.strokeStyle = `rgba(255,255,255,${PERFECT_FLASH.t})`;
    ctx.lineWidth = 2;
    ctx.strokeRect(b.x-4, b.y-4, b.w+8, b.h+8);
  }

  ctx.restore();

  // ガイド（センター）
  ctx.strokeStyle = 'rgba(255,255,255,.06)';
  ctx.beginPath(); ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h); ctx.stroke();

  // 風アイコン
  if (gustVX){
    ctx.fillStyle = 'rgba(255,255,255,.2)';
    for(let i=0;i<5;i++){
      const y = 30 + i*14;
      const len = 22 + i*6;
      if (gustVX>0){ ctx.fillRect(w-30-len, y, len, 2); }
      else         { ctx.fillRect(30, y, len, 2); }
    }
  }
}

/* ===== 成否 ===== */
function success(){
  playing=false;
  SecretDex.grant(67);
  ovMsg.textContent = '解放成功！';
  ovSub.textContent = '#67 が使えるようになりました。';
  ov.style.display = 'grid';
}
function fail(msg){
  playing=false;
  ovMsg.textContent = '失敗…';
  ovSub.textContent = msg || 'ずれて落ちました。';
  ov.style.display = 'grid';
}

/* ===== 入力 ===== */
function onPress(e){ e && e.preventDefault(); if(!playing){ start(); return; } release(); }
cv.addEventListener('pointerdown', onPress, {passive:false});
addEventListener('keydown', (e)=>{ if(e.code==='Space'){ onPress(e); }});
document.addEventListener('visibilitychange', ()=>{ if(document.hidden) playing=false; });

startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);

/* 初期描画 */
reset();
</script>
</body>
</html>
