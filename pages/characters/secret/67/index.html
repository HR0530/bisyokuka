<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Secret #67：Ghost Chase Hell+</title>
<style>
  :root{--bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;--accent:#f59e0b;--muted:#94a3b8}
  *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui}
  .wrap{max-width:960px;margin:24px auto;padding:16px}
  .panel{position:relative;background:var(--card);border:1px solid #223047;border-radius:14px;padding:12px}
  .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .stats{display:flex;gap:14px;align-items:center}
  .badge{background:#0b1626;border:1px solid #1b2944;border-radius:999px;padding:6px 10px;font-weight:800}
  .muted{color:var(--muted);text-decoration:none}
  .btn{background:var(--accent);color:#1a1204;border:none;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer}
  .btn.ghost{background:#0ea5e9;color:#031423}
  canvas{
    display:block;width:100%;
    height:clamp(360px, calc(100svh - 260px), 700px);
    margin-top:8px;border-radius:12px;border:1px solid #1a2740;background:#0a1523
  }
  @media (max-width:640px){ canvas{height:420px} }
  .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.5)}
  .sheet{background:#111827;border:1px solid #243042;border-radius:14px;padding:18px;min-width:60%;display:grid;gap:10px;justify-items:center}
  .hud-right{position:absolute;right:10px;top:10px;display:flex;gap:8px}
  .mini{background:#0b1626;border:1px solid #1b2944;border-radius:10px;color:#e5e7eb;padding:6px 10px;font-weight:700;cursor:pointer}
</style>
</head>
<body>
<div class="wrap">
  <h1>Secret #67：Ghost Chase Hell+</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">条件：<b>25秒生存</b>（HELL+）</span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span>残像：<b id="echoes">0</b>/3</span>
      </div>
      <div class="row" style="gap:8px">
        <button class="btn" id="startBtn">START</button>
        <a class="muted" href="../../dex/index.html">← 図鑑へ戻る</a>
      </div>
    </div>

    <div class="hud-right">
      <button class="mini" id="dashBtn" title="タップでもダッシュ">DASH</button>
    </div>

    <canvas id="cv"></canvas>

    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:900;font-size:18px"></div>
        <div id="ovSub" class="muted"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>
  <p class="muted" style="margin-top:8px">
    操作：<b>WASD / 方向キー</b>で移動、<b>Space / DASH</b>でダッシュ（短距離・クールダウン有）。<br/>
    12秒経過で2体目のゴースト出現。過去の自分の残像（Echo）が最大3体出ます。視界は徐々に狭くなります。
  </p>
</div>

<script>
/* ===== SecretDex（保存/解放ユーティリティ） ===== */
const DEX_KEY='dex_state_v1';
const SID = 67;                 // この挑戦の番号
const ID  = SID - 1;            // 0始まりID
const FILE= `secret_${SID}.png`;

const SecretDex = {
  load(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY)||'{}'); }catch{ return {}; } },
  save(v){ localStorage.setItem(DEX_KEY, JSON.stringify(v||{})); },
  grant(no=SID){
    const id = (no|0)-1, file = `secret_${no}.png`;
    const dex = this.load();
    dex.unlocked   = dex.unlocked   || {};
    dex.secretFiles= dex.secretFiles|| {};
    dex.unlocked[id] = true;
    dex.secretFiles[String(id)] = file;
    if(!dex.selected) dex.selected = file;
    this.save(dex);
    try{ window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)})); }catch(_){}
  }
};

/* ===== Canvas 高DPI対応 ===== */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', fitCanvas, {passive:true}); fitCanvas();

/* ===== DOM ===== */
const startBtn = document.getElementById('startBtn');
const dashBtn  = document.getElementById('dashBtn');
const timeEl   = document.getElementById('time');
const echoesEl = document.getElementById('echoes');
const ov       = document.getElementById('ov');
const ovMsg    = document.getElementById('ovMsg');
const ovSub    = document.getElementById('ovSub');
const retryBtn = document.getElementById('retryBtn');

/* ===== HELL+ パラメータ（激むず） ===== */
const TIME_NEED     = 25.0;
const ARENA_PAD     = 24;
const P_SPEED       = 210;
const DASH_SPEED    = 560;
const DASH_TIME     = 0.16;
const DASH_CD       = 0.55;
const G1_BASE       = 170, G1_END = 290;
const G2_SPAWN_T    = 12.0;
const G2_BASE       = 150, G2_END = 260;
const TELEPORT_INT1 = [5.0, 7.0];
const TELEPORT_INT2 = [6.0, 8.0];
const TELEPORT_DIST = [120, 280];
const TELEP_FLASH   = 0.20;
const ECHO_MAX      = 3;
const ECHO_DELAY    = 0.28;
const ECHO_SPAWN_T1 = 8.0, ECHO_SPAWN_T2 = 14.0, ECHO_SPAWN_T3 = 19.0;
const LANTERN_MAX   = 180, LANTERN_MIN = 110;
const HURT_R        = 14;

/* ===== 状態 ===== */
let playing=false, last=0, t0=0, raf=0;
let timeNow=0;
let px=0, py=0, vx=0, vy=0;
let dashT=0, dashCD=0;
let keys = new Set();
let ghosts = []; // {x,y,spd,telAt,flashT}
let echoes = []; // [{trail: [{x,y}], idx:0, spd}]
let trail  = []; // 自分の軌跡
let trailAcc=0;

/* ===== 入力 ===== */
addEventListener('keydown', e=>{
  if (e.repeat) return;
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD',' '].includes(e.code)) e.preventDefault();
  if (e.code==='Space'){ dash(); return; }
  keys.add(e.code);
});
addEventListener('keyup', e=> keys.delete(e.code));
dashBtn.addEventListener('click', dash);
cv.addEventListener('pointerdown', e=>{
  const rect=cv.getBoundingClientRect();
  const tx=e.clientX-rect.left, ty=e.clientY-rect.top;
  const dx=tx-px, dy=ty-py; const L=Math.hypot(dx,dy)||1;
  vx = (dx/L)*P_SPEED; vy=(dy/L)*P_SPEED;
  dash();
},{passive:true});

/* ===== 主要関数 ===== */
function resetGame(){
  cancelAnimationFrame(raf);
  playing=false; timeNow=0; last=0; t0=0;
  const w=cv.clientWidth, h=cv.clientHeight;
  px = w/2; py = h/2; vx=0; vy=0; dashT=0; dashCD=0;
  ghosts.length=0; echoes.length=0; trail.length=0; trailAcc=0;
  spawnGhost(1); scheduleTeleport(ghosts[0], TELEPORT_INT1);
  timeEl.textContent='0.0'; echoesEl.textContent='0';
  ov.style.display='none';
  drawScene(0, 0);
}
function start(){
  resetGame();
  playing=true;
  t0=performance.now(); last=t0;
  raf=requestAnimationFrame(loop);
}
function succeed(){
  playing=false;
  SecretDex.grant(SID);
  ovMsg.textContent='解放成功！ #67';
  ovSub.textContent='図鑑で選択できます。';
  ov.style.display='grid';
}
function fail(reason='捕まった…'){
  playing=false;
  ovMsg.textContent='失敗…';
  ovSub.textContent=`${reason}（25秒生存でクリア）`;
  ov.style.display='grid';
}

/* ===== ゴースト・残像 ===== */
function spawnGhost(no){
  ghosts.push({
    no,
    x: px + (Math.random()<0.5?-1:1)*160,
    y: py + (Math.random()<0.5?-1:1)*160,
    spd: no===1 ? G1_BASE : G2_BASE,
    telAt: 0,
    flashT: 0
  });
}
function scheduleTeleport(g, range){
  const [a,b]=range;
  g.telAt = timeNow + (a + Math.random()*(b-a));
}
function teleportGhost(g){
  g.flashT = TELEP_FLASH;
  const dist = TELEPORT_DIST[0] + Math.random()*(TELEPORT_DIST[1]-TELEPORT_DIST[0]);
  const ang = Math.atan2(vy||0, vx||0) + (Math.PI * (0.8 + Math.random()*0.4));
  const tx = clamp(px + Math.cos(ang)*dist, ARENA_PAD, cv.clientWidth-ARENA_PAD);
  const ty = clamp(py + Math.sin(ang)*dist, ARENA_PAD, cv.clientHeight-ARENA_PAD);
  g.x = tx; g.y = ty;
  scheduleTeleport(g, g.no===1?TELEPORT_INT1:TELEPORT_INT2);
}

/* ===== ループ ===== */
function loop(ts){
  if (!playing) return;
  let dt=(ts-last)/1000; last=ts;
  timeNow=(ts-t0)/1000; timeEl.textContent=timeNow.toFixed(1);

  if (ghosts.length===1 && timeNow>=G2_SPAWN_T){
    spawnGhost(2); scheduleTeleport(ghosts[1], TELEPORT_INT2);
  }

  const k = Math.min(1, timeNow/TIME_NEED);
  const lanternR = LANTERN_MAX + (LANTERN_MIN-LANTERN_MAX)*k;

  // 入力→速度
  let ax=0, ay=0;
  if (keys.has('ArrowUp')||keys.has('KeyW')) ay-=1;
  if (keys.has('ArrowDown')||keys.has('KeyS')) ay+=1;
  if (keys.has('ArrowLeft')||keys.has('KeyA')) ax-=1;
  if (keys.has('ArrowRight')||keys.has('KeyD')) ax+=1;
  const L = Math.hypot(ax,ay);
  if (dashT>0){ dashT-=dt; } else {
    if (L>0){ vx=(ax/L)*P_SPEED; vy=(ay/L)*P_SPEED; }
    else { vx*=0.86; vy*=0.86; }
  }
  px = clamp(px + vx*dt, ARENA_PAD, cv.clientWidth-ARENA_PAD);
  py = clamp(py + vy*dt, ARENA_PAD, cv.clientHeight-ARENA_PAD);

  // 残像（自分の軌跡）
  trailAcc += dt;
  if (trailAcc >= ECHO_DELAY){
    trailAcc = 0;
    trail.unshift({x:px, y:py});
    if (trail.length > Math.round((TIME_NEED+5)/ECHO_DELAY)) trail.pop();
  }
  if (timeNow>=ECHO_SPAWN_T1 && echoes.length<1) makeEcho(0.9);
  if (timeNow>=ECHO_SPAWN_T2 && echoes.length<2) makeEcho(0.95);
  if (timeNow>=ECHO_SPAWN_T3 && echoes.length<3) makeEcho(1.0);
  echoesEl.textContent = echoes.length;

  // ゴースト追跡・テレポ
  for (const g of ghosts){
    const target = predictTarget();
    const gBase = g.no===1 ? G1_BASE : G2_BASE;
    const gEnd  = g.no===1 ? G1_END  : G2_END;
    const spd = gBase + (gEnd-gBase)*k;
    g.spd = spd;

    if (timeNow >= g.telAt) teleportGhost(g);
    else if (g.flashT > 0) g.flashT -= dt;

    const dx = target.x - g.x, dy = target.y - g.y;
    const dL = Math.hypot(dx,dy)||1;
    g.x += (dx/dL) * spd * dt;
    g.y += (dy/dL) * spd * dt;
  }

  // 残像追尾
  for (const e of echoes){
    if (e.idx < e.trail.length-1){
      const p = e.trail[e.idx];
      const dx = p.x - e.x, dy = p.y - e.y;
      const L = Math.hypot(dx,dy)||1;
      const step = e.spd*dt;
      if (L <= step){ e.x = p.x; e.y = p.y; e.idx++; }
      else { e.x += dx/L*step; e.y += dy/L*step; }
    }
  }

  // 当たり判定
  for (const g of ghosts){ if (dist(px,py,g.x,g.y) <= HURT_R){ fail(); return; } }
  for (const e of echoes){ if (dist(px,py,e.x,e.y) <= HURT_R*0.9){ fail('過去の自分に捕まった…'); return; } }

  if (timeNow >= TIME_NEED){ succeed(); return; }

  drawScene(lanternR, k);
  raf=requestAnimationFrame(loop);
}

/* ===== 補助 ===== */
function dash(){
  if (dashT>0 || dashCD>0) return;
  dashT = DASH_TIME; dashCD = DASH_CD;
  const L = Math.hypot(vx,vy);
  let ux=1, uy=0;
  if (L>0){ ux=vx/L; uy=vy/L; } else { const a=Math.random()*Math.PI*2; ux=Math.cos(a); uy=Math.sin(a); }
  vx = ux * DASH_SPEED; vy = uy * DASH_SPEED;
  const id = setInterval(()=>{ dashCD -= 0.05; if (dashCD<=0){ dashCD=0; clearInterval(id); } },50);
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy); }
function predictTarget(){
  const look = 0.18 + Math.min(0.32, timeNow*0.012);
  return { x: clamp(px + vx*look, ARENA_PAD, cv.clientWidth-ARENA_PAD),
           y: clamp(py + vy*look, ARENA_PAD, cv.clientHeight-ARENA_PAD) };
}
function makeEcho(slow=1.0){
  const eTrail = trail.slice().reverse();
  const start = eTrail[0] || {x:px,y:py};
  echoes.push({ x:start.x, y:start.y, trail:eTrail, idx:0, spd: P_SPEED*0.9*slow });
}

/* ===== 描画 ===== */
function drawScene(lanternR, k){
  const w=cv.clientWidth, h=cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景グリッド
  const drift = (timeNow*40)%40;
  ctx.fillStyle='#0f2338';
  for(let y=ARENA_PAD;y<h-ARENA_PAD;y+=40){ ctx.fillRect(ARENA_PAD, Math.floor(y+drift)%h, w-ARENA_PAD*2, 1); }
  for(let x=ARENA_PAD;x<w-ARENA_PAD;x+=40){ ctx.fillRect(Math.floor(x+drift)%w, ARENA_PAD, 1, h-ARENA_PAD*2); }
  ctx.strokeStyle='#162a44'; ctx.lineWidth=2; ctx.strokeRect(ARENA_PAD,ARENA_PAD,w-ARENA_PAD*2,h-ARENA_PAD*2);

  // 残像
  for (const e of echoes){ ctx.fillStyle='rgba(250,204,21,0.85)'; ctx.beginPath(); ctx.arc(e.x, e.y, 7, 0, Math.PI*2); ctx.fill(); }

  // ゴースト
  for (const g of ghosts){
    if (g.flashT>0){ ctx.strokeStyle='rgba(239,68,68,0.8)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(g.x, g.y, 18, 0, Math.PI*2); ctx.stroke(); }
    const aura=`rgba(239,68,68,${0.25+0.35*Math.sin((timeNow*6)%Math.PI)})`;
    ctx.fillStyle=aura;  ctx.beginPath(); ctx.arc(g.x, g.y, 20, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='rgba(239,68,68,0.9)'; ctx.beginPath(); ctx.arc(g.x, g.y, 10, 0, Math.PI*2); ctx.fill();
  }

  // プレイヤー
  ctx.fillStyle='#22d3ee'; ctx.beginPath(); ctx.arc(px, py, 8, 0, Math.PI*2); ctx.fill();
  if (dashT>0){ ctx.strokeStyle='rgba(34,211,238,.6)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(px, py, 14, 0, Math.PI*2); ctx.stroke(); }

  // 視界
  const grd = ctx.createRadialGradient(px,py, Math.max(10,lanternR*0.35), px,py, lanternR);
  grd.addColorStop(0, 'rgba(0,0,0,0)'); grd.addColorStop(1, 'rgba(0,0,0,0.85)');
  ctx.fillStyle = grd; ctx.fillRect(0,0,w,h);
}

/* ===== 起動・UI ===== */
startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);

resetGame();
</script>
</body>
</html>
