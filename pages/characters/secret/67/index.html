<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- あれば使う（無ければ下のフォールバックで解放処理を行います） -->
  <script src="../_unlock.js"></script>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>シークレット挑戦 #67：Orbit Switch Arena（激むず・調整版）</title>
  <style>
    :root{--bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;--accent:#a78bfa;--muted:#9ca3af}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:900px;margin:24px auto;padding:16px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
    .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .btn{background:var(--accent);color:#0a0713;border:none;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
    .btn.ghost{background:#0ea5e9;color:#031423}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .muted{color:var(--muted);text-decoration:none}
    .stats{display:flex;gap:16px;align-items:center}
    .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
    canvas{
      display:block;width:100%;
      height:clamp(340px, calc(100svh - 260px), 700px);
      margin-top:10px;background:linear-gradient(#0f2238,#0b1626);
      border-radius:12px;border:1px solid #1a2740
    }
    @media (max-width:640px){ canvas{height:380px} }

    .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45)}
    .overlay .sheet{background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;
      display:grid;gap:10px;justify-items:center}
  </style>
</head>
<body>
<div class="wrap">
  <h1>シークレット挑戦 #67：Orbit Switch Arena（激むず・調整）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge" id="badge">条件：18秒生存 ＋ シャード8個</span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span>シャード：<b id="shards">0</b>/<b id="need">8</b></span>
      </div>
      <div class="row" style="gap:10px">
        <button class="btn" id="startBtn">START</button>
        <a class="muted" href="../../dex/index.html">← 図鑑へ戻る</a>
      </div>
    </div>

    <canvas id="cv"></canvas>

    <!-- 成否オーバーレイ -->
    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>

  <div class="muted" style="margin-top:8px;line-height:1.6">
    操作：タップ/クリック or <b>SPACE</b> で <b>内軌道⇔外軌道</b> を切替。<br/>
    黄色い警告アークは <b>約0.9秒</b> 後に赤（危険）へ。<br/>
    目標：<b>18秒</b> 生存 ＋ <b>シャード8個</b> 回収。<br/>
    さらに易しい「お助け」：URLに <code>?assist=1</code> を付けるとさらに優しめ設定になります。
  </div>
</div>

<script>
/* ================== 解放ヘルパー（_unlock.js 無い場合のフォールバック） ================== */
(function ensureGrant(){
  if (window.SecretDex && typeof window.SecretDex.grant==='function') return;
  window.SecretDex = {
    grant(no){
      const DEX_KEY = 'dex_state_v1';
      const id = no - 1; // 0始まり id
      const file = `secret_${no}.png`;
      let dex = {};
      try{ dex = JSON.parse(localStorage.getItem(DEX_KEY)||'{}') }catch{}
      dex.unlocked = dex.unlocked || {};
      dex.secretFiles = dex.secretFiles || {};
      dex.unlocked[id] = true;
      dex.secretFiles[String(id)] = file;
      if(!dex.selected) dex.selected = file;
      localStorage.setItem(DEX_KEY, JSON.stringify(dex));
      try{ window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)})); }catch(_){}
    }
  };
})();

/* ================== 難易度（やさしめ調整済み） ================== */
let TIME_NEED     = 18.0;   // クリア生存秒
let SHARDS_NEED   = 8;      // 必要シャード数
let WARN_TIME     = 0.9;    // 黄色予告→赤まで
let SPAWN_BASE    = 1.15;   // アーク出現間隔（長い=易）
let SPAWN_MIN     = 0.85;
let COIN_BASE     = 0.75;   // シャード出現間隔
let COIN_MIN      = 0.48;
let ARC_W_MIN_DEG = 20;     // アーク角幅（小さい=避けやすい）
let ARC_W_MAX_DEG = 46;
let SPEED_START   = 1.5;    // プレイヤー角速度[rad/s]
let SPEED_END     = 2.1;
let R_IN_FR       = 0.30;   // 内軌道 半径比
let R_OUT_FR      = 0.42;   // 外軌道 半径比
let DOT_R         = 6;      // プレイヤー半径(描画)
let COIN_R        = 7;
let HIT_PAD       = 0.10;   // 当たり許容[rad]（大きい=当たりにくい）
let SWAP_CD       = 0.16;   // 連続切替のクールダウン

// アシストモード (?assist=1) ならさらに易化
(function maybeAssist(){
  const p = new URLSearchParams(location.search);
  if (p.get('assist')==='1'){
    TIME_NEED   = 16.0;
    SHARDS_NEED = 6;
    WARN_TIME   = 1.05;
    SPAWN_BASE  = 1.25;
    SPAWN_MIN   = 0.95;
    COIN_BASE   = 0.65;
    COIN_MIN    = 0.42;
    SPEED_START = 1.35;
    SPEED_END   = 1.9;
    ARC_W_MIN_DEG = 18;
    ARC_W_MAX_DEG = 42;
    HIT_PAD = 0.11;
  }
  // バッジ文言を同期
  document.getElementById('badge').innerHTML =
    `条件：<b>${TIME_NEED.toFixed(0)}秒生存</b> ＋ <b>シャード${SHARDS_NEED}個</b>`;
  document.getElementById('need').textContent = SHARDS_NEED;
})();

/* ================== Canvas セットアップ（高DPI/見切れ防止） ================== */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', fitCanvas, {passive:true}); fitCanvas();

/* ================== DOM ================== */
const timeEl   = document.getElementById('time');
const shardEl  = document.getElementById('shards');
const startBtn = document.getElementById('startBtn');
const ov       = document.getElementById('ov');
const ovMsg    = document.getElementById('ovMsg');
const ovSub    = document.getElementById('ovSub');
const retryBtn = document.getElementById('retryBtn');

/* ================== ゲーム状態 ================== */
let playing=false, t0=0, last=0, raf=0, paused=false;
let angle=0, speed=SPEED_START, ring=0; // ring: 0=内,1=外
let swapLock=0;
let arcs=[], coins=[];
let tArc=0, tCoin=0;
let timeNow=0, shardCount=0;

/* ================== リセット ================== */
function resetGame(){
  cancelAnimationFrame(raf);
  playing=false; paused=false;
  angle=0; speed=SPEED_START; ring=0; swapLock=0;
  arcs.length=0; coins.length=0;
  tArc = 0.3; tCoin = 0.2;
  timeNow=0; shardCount=0;
  timeEl.textContent='0.0'; shardEl.textContent='0';
  ov.style.display='none';
  drawScene(0);
}

/* ================== 入力（切替） ================== */
function trySwap(){
  if(!playing || paused) return;
  const now = performance.now()/1000;
  if(now < swapLock) return;
  ring = (ring^1);
  swapLock = now + SWAP_CD;
}
cv.addEventListener('pointerdown', trySwap, {passive:true});
addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); trySwap(); }});

/* タブ非表示で一時停止 */
document.addEventListener('visibilitychange', ()=>{ if(playing) paused = document.hidden; });

/* ================== 生成 ================== */
const TAU = Math.PI*2;
function rand(a,b){ return a + Math.random()*(b-a); }
function spawnArc(){
  const onOuter = Math.random()<0.5 ? 0 : 1; // 0=内,1=外  ※内の方が安全に寄りがちなので均等
  const wDeg = rand(ARC_W_MIN_DEG, ARC_W_MAX_DEG);
  const w = wDeg * Math.PI/180;
  const a = rand(0, TAU);
  arcs.push({ ring:onOuter, a, w, t:0, warn:true }); // warn中→赤へ
}
function spawnCoin(){
  const r = Math.random()<0.5 ? 0 : 1;
  const a = rand(0, TAU);
  coins.push({ ring:r, a, taken:false });
}

/* ================== ループ ================== */
function loop(ts){
  if(!playing) return;
  if(!last) last = ts;
  let dt = Math.min(0.033, (ts-last)/1000); // 安定化
  last = ts;
  if(paused){ raf = requestAnimationFrame(loop); return; }

  timeNow = (ts - t0)/1000;
  timeEl.textContent = timeNow.toFixed(1);

  // 角速度をゆっくり上げる（体感は緩やか）
  const k = Math.min(1, timeNow / TIME_NEED);
  speed = SPEED_START + (SPEED_END - SPEED_START)*k;
  angle = (angle + speed*dt) % TAU;

  // スポーン（だんだん密に）
  tArc -= dt; tCoin -= dt;
  const arcInt  = Math.max(SPAWN_MIN,  SPAWN_BASE  - 0.02*timeNow);
  const coinInt = Math.max(COIN_MIN,   COIN_BASE   - 0.015*timeNow);
  if(tArc  <= 0){ tArc  += arcInt;  spawnArc(); }
  if(tCoin <= 0){ tCoin += coinInt; spawnCoin(); }

  // アーク進行（黄色→赤）
  for(const x of arcs){ x.t += dt; if(x.warn && x.t >= WARN_TIME){ x.warn=false; } }
  // 当たり判定（角度差のみでOK）
  const pAng = angle, pRing = ring;
  // シャード
  for(const c of coins){
    if(c.taken) continue;
    if(c.ring !== pRing) continue;
    let da = Math.abs((c.a - pAng + TAU) % TAU);
    if(da > Math.PI) da = TAU - da;
    if(da <= (COIN_R/60) + HIT_PAD*0.6){ // 取りやすめ
      c.taken = true;
      shardCount++; shardEl.textContent = shardCount;
    }
  }
  // アーク（赤のみ致死）
  for(const a of arcs){
    if(a.warn) continue;
    if(a.ring !== pRing) continue;
    // アーク中心角との差
    let da = Math.abs((a.a - pAng + TAU) % TAU);
    if(da > Math.PI) da = TAU - da;
    const half = a.w/2 + HIT_PAD;
    if(da <= half){
      return fail('赤アークに接触…');
    }
  }

  // 古い要素の掃除（寿命）
  arcs  = arcs.filter(x => x.t < WARN_TIME + 2.0); // 赤になってからも少しで消える
  coins = coins.filter(c => !c.taken && Math.abs(((c.a - pAng + TAU)%TAU)) < TAU*0.9);

  // 描画
  drawScene(dt);

  // クリア判定
  if(timeNow >= TIME_NEED && shardCount >= SHARDS_NEED){
    return success();
  }

  raf = requestAnimationFrame(loop);
}

/* ================== 描画 ================== */
function drawScene(dt){
  const w = cv.clientWidth, h = cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#0f2238'); g.addColorStop(1,'#0b1626');
  ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

  // 円形アリーナ
  const cx = w/2, cy = h/2;
  const R  = Math.min(w,h)*0.5 - 24;
  const rIn  = R*R_IN_FR, rOut = R*R_OUT_FR;

  // ガイド円
  ctx.strokeStyle = 'rgba(255,255,255,.18)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(cx,cy,rIn,0,TAU); ctx.stroke();
  ctx.beginPath(); ctx.arc(cx,cy,rOut,0,TAU); ctx.stroke();

  // アーク
  for(const a of arcs){
    const r = a.ring? rOut : rIn;
    ctx.lineWidth = 10;
    ctx.strokeStyle = a.warn ? '#fbbf24' : '#ef4444';
    ctx.beginPath();
    ctx.arc(cx,cy,r, a.a - a.w/2, a.a + a.w/2);
    ctx.stroke();
  }

  // コイン（シャード）
  for(const c of coins){
    const r = c.ring? rOut : rIn;
    const x = cx + Math.cos(c.a)*r;
    const y = cy + Math.sin(c.a)*r;
    ctx.beginPath(); ctx.arc(x,y,COIN_R,0,TAU);
    ctx.fillStyle = '#fbbf24'; ctx.fill();
    ctx.lineWidth = 2; ctx.strokeStyle = '#fde68a'; ctx.stroke();
  }

  // プレイヤー
  const pr = ring? rOut : rIn;
  const px = cx + Math.cos(angle)*pr;
  const py = cy + Math.sin(angle)*pr;
  ctx.beginPath(); ctx.arc(px,py,DOT_R,0,TAU);
  ctx.fillStyle = '#60a5fa'; ctx.fill();

  // 中心点
  ctx.beginPath(); ctx.arc(cx,cy,3,0,TAU);
  ctx.fillStyle = 'rgba(255,255,255,.35)'; ctx.fill();
}

/* ================== 成否 ================== */
function fail(msg){
  playing=false;
  ovMsg.textContent = '失敗…';
  ovSub.textContent = `${msg}（条件：${TIME_NEED.toFixed(0)}秒 ＆ シャード${SHARDS_NEED}）`;
  ov.style.display = 'grid';
}
function success(){
  playing=false;
  // #67 を解放
  window.SecretDex.grant(67);
  ovMsg.textContent = '解放成功！ #67 が使えるようになった';
  ovSub.textContent = '図鑑で選択できます。';
  ov.style.display = 'grid';
}

/* ================== 開始・再試行 ================== */
function start(){
  resetGame();
  playing = true; paused = false;
  t0 = performance.now(); last = t0;
  raf = requestAnimationFrame(loop);
}
startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);

/* 初期化 */
resetGame();
</script>
</body>
</html>
