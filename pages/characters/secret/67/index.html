<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>シークレット挑戦 #67：Echo Runner（激むず）</title>
<style>
  :root{
    --bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;
    --accent:#eab308;--ok:#22c55e;--warn:#ef4444;--muted:#9ca3af
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:920px;margin:22px auto;padding:16px}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
  .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .stats{display:flex;gap:16px;align-items:center}
  .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:800}
  .muted{color:var(--muted);text-decoration:none}
  .btn{background:var(--accent);color:#1f1703;border:none;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
  .btn.ghost{background:#0ea5e9;color:#042031}
  .btn.warn{background:var(--warn);color:#2b0b0b}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  canvas{
    display:block;width:100%;
    height:clamp(360px, calc(100svh - 260px), 680px);
    margin-top:10px;border-radius:12px;border:1px solid #1a2740;
    background:radial-gradient(120% 100% at 50% 0%, #0f2238 0%, #0b1626 60%)
  }
  @media (max-width:640px){ canvas{height:420px} }

  .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45)}
  .overlay .sheet{background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;display:grid;gap:10px;justify-items:center}
</style>
</head>
<body>
<div class="wrap">
  <h1>シークレット挑戦 #67：Echo Runner（激むず）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">条件：<b>35秒以内</b>に<b>コイン9枚</b>回収</span>
        <span>残り：<b id="timeLeft">35.0</b>s</span>
        <span>コイン：<b id="coins">0</b>/9</span>
        <span class="muted">Space：ブレーキ（短時間）</span>
      </div>
      <div class="row" style="gap:8px">
        <button class="btn" id="startBtn">START</button>
        <button class="btn warn" id="resetBtn" title="#67の解放状態を消します">#67リセット</button>
        <a class="btn ghost" href="../../dex/index.html">図鑑へ</a>
      </div>
    </div>
    <canvas id="cv"></canvas>

    <!-- 成否オーバーレイ -->
    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>

  <div class="muted" style="margin-top:8px">
    操作：WASD / 方向キーで移動。Space で短時間ブレーキ（クールダウンあり）。<br/>
    5秒前の自分の軌跡（ゴースト）に触れると失敗。フォーカスを外すと一時停止します。<br/>
    URLに <code>?reset=1</code> を付けて開くと、開始時に#67の解放をリセットします。
  </div>
</div>

<script>
/* ---------- 解放管理 (#67) ---------- */
(function(){
  // _unlock.js が無くても動くフォールバック
  if (!window.SecretDex) {
    window.SecretDex = {
      grant(no){
        const DEX_KEY='dex_state_v1', id=no-1, file=`secret_${no}.png`;
        let dex={}; try{ dex=JSON.parse(localStorage.getItem(DEX_KEY)||'{}') }catch{}
        dex.unlocked=dex.unlocked||{}; dex.secretFiles=dex.secretFiles||{};
        dex.unlocked[id]=true; dex.secretFiles[String(id)]=file;
        if(!dex.selected) dex.selected=file;
        localStorage.setItem(DEX_KEY, JSON.stringify(dex));
        try{ window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)})); }catch(_){}
      },
      reset(no){
        const DEX_KEY='dex_state_v1', id=no-1, file=`secret_${no}.png`;
        let dex={}; try{ dex=JSON.parse(localStorage.getItem(DEX_KEY)||'{}') }catch{}
        if(dex.unlocked){ delete dex.unlocked[id]; }
        if(dex.secretFiles){ delete dex.secretFiles[String(id)]; }
        if(dex.selected===file){ dex.selected='char.png'; } // 選択中だったら戻す
        localStorage.setItem(DEX_KEY, JSON.stringify(dex));
        try{ window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)})); }catch(_){}
      }
    };
  }
})();

/* URL ?reset=1 なら開始時リセット */
if (new URL(location.href).searchParams.get('reset')==='1'){
  SecretDex.reset(67);
}

/* ---------- Canvas & 高DPI ---------- */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', fitCanvas, {passive:true});
fitCanvas();

/* ---------- UI ---------- */
const startBtn  = document.getElementById('startBtn');
const resetBtn  = document.getElementById('resetBtn');
const retryBtn  = document.getElementById('retryBtn');
const timeEl    = document.getElementById('timeLeft');
const coinsEl   = document.getElementById('coins');
const ov        = document.getElementById('ov');
const ovMsg     = document.getElementById('ovMsg');
const ovSub     = document.getElementById('ovSub');

/* ---------- ゲーム定数（激むず） ---------- */
const FIELD_PAD = 16;
const TIME_LIMIT = 35.0;           // クリア制限
const TARGET_COINS = 9;            // 必要コイン
const P_RADIUS = 12;               // プレイヤー半径
const G_RADIUS = 12;               // ゴースト半径（当たり判定）
const SPEED = 165;                 // 通常速度(px/s)
const ACCEL = 880;                 // 加速力
const FRICTION = 0.92;             // 微減速
const BRAKE_FACTOR = 0.28;         // ブレーキ時速度係数
const BRAKE_TIME = 0.22;           // ブレーキ持続
const BRAKE_CD = 1.2;              // ブレーキCD
const DELAY = 4.5;                 // ゴーストの遅延（秒）
const TRAIL_CAP = 10;              // 軌跡保持秒数（>DELAY）
const COIN_R = 8;
const HIT_FORGIVE = 1.0;           // 当たり判定ゆるみ
const WALLS_COUNT = 6;             // 壁の数（ランダム配置）

/* ---------- 状態 ---------- */
let playing=false, paused=false, t0=0, last=0, raf=0;
let timeLeft=TIME_LIMIT, coinCount=0;
let px=0, py=0, vx=0, vy=0;
let braking=false, brakeTimer=0, brakeCd=0;
let keys={};
let trail=[]; // {t,x,y}
let ghost={x:0,y:0,ready:false};
let coins=[], walls=[];

/* ---------- 入力 ---------- */
addEventListener('keydown', e=>{
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
  keys[e.key]=true;
  if (e.key===' ') tryBrake();
});
addEventListener('keyup', e=>{ keys[e.key]=false; });
cv.addEventListener('pointerdown', ()=> tryBrake(), {passive:true});

/* ---------- ポーズ ---------- */
document.addEventListener('visibilitychange', ()=>{
  if(!playing) return;
  paused = document.hidden;
});

/* ---------- 乱数ユーティリティ ---------- */
function rand(a,b){ return a + Math.random()*(b-a); }
function choice(arr){ return arr[(Math.random()*arr.length)|0]; }

/* ---------- 壁・コイン生成 ---------- */
function randWalls(){
  walls.length=0;
  const W=cv.clientWidth, H=cv.clientHeight, pad=FIELD_PAD+30;
  for(let i=0;i<WALLS_COUNT;i++){
    const w=rand(80,140), h=rand(24,90);
    const x=rand(pad, W-pad-w), y=rand(pad, H-pad-h);
    walls.push({x,y,w,h});
  }
}
function genCoins(){
  coins.length=0;
  const W=cv.clientWidth, H=cv.clientHeight, pad=FIELD_PAD+22;
  const tries = 80;
  while(coins.length < TARGET_COINS+3 && coins.length<18){
    const x=rand(pad, W-pad), y=rand(pad, H-pad);
    // 壁やプレイヤー開始位置に近すぎない
    if (dist(x,y,px,py) < 100) continue;
    if (walls.some(w=> rectCircleOverlap(w,x,y,COIN_R+2))) continue;
    coins.push({x,y,taken:false});
    if (coins.length>tries) break;
  }
}

/* ---------- 幾何 ---------- */
function dist(x1,y1,x2,y2){ const dx=x1-x2, dy=y1-y2; return Math.hypot(dx,dy); }
function rectCircleOverlap(r, cx, cy, cr){
  const nx = Math.max(r.x, Math.min(cx, r.x+r.w));
  const ny = Math.max(r.y, Math.min(cy, r.y+r.h));
  return dist(nx,ny,cx,cy) <= cr;
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* ---------- ブレーキ ---------- */
function tryBrake(){
  if(!playing||paused) return;
  if (brakeCd>0 || braking) return;
  braking=true; brakeTimer=BRAKE_TIME; brakeCd=BRAKE_CD;
}

/* ---------- リセット/開始 ---------- */
function resetGame(){
  cancelAnimationFrame(raf);
  playing=false; paused=false;
  timeLeft=TIME_LIMIT; coinCount=0;
  timeEl.textContent=timeLeft.toFixed(1);
  coinsEl.textContent='0';

  // 初期位置：中央
  px=cv.clientWidth/2; py=cv.clientHeight/2;
  vx=0; vy=0;
  braking=false; brakeTimer=0; brakeCd=0;

  // フィールド生成
  randWalls();
  genCoins();

  // 軌跡クリア
  trail.length=0;
  ghost={x:px, y:py, ready:false};

  ov.style.display='none';
  draw(0); // 初期描画
}
function start(){
  resetGame();
  playing=true; paused=false;
  t0=performance.now(); last=t0;
  raf=requestAnimationFrame(loop);
}

/* ---------- ループ ---------- */
function loop(ts){
  if(!playing) return;
  if(paused){ last=ts; raf=requestAnimationFrame(loop); return; }
  const dt = Math.min(0.033, (ts-last)/1000); last=ts;

  // 時間
  timeLeft -= dt;
  if (timeLeft <= 0){
    fail('時間切れ…');
    return;
  }
  timeEl.textContent = Math.max(0,timeLeft).toFixed(1);

  // 入力 → 加速
  let ax=0, ay=0;
  const up=keys['ArrowUp']||keys['w']||keys['W'];
  const dn=keys['ArrowDown']||keys['s']||keys['S'];
  const lf=keys['ArrowLeft']||keys['a']||keys['A'];
  const rt=keys['ArrowRight']||keys['d']||keys['D'];
  if(up) ay -= ACCEL;
  if(dn) ay += ACCEL;
  if(lf) ax -= ACCEL;
  if(rt) ax += ACCEL;

  // 速度更新
  vx += ax*dt; vy += ay*dt;

  // 速度制限
  const spd = Math.hypot(vx,vy);
  const limit = SPEED * (braking ? BRAKE_FACTOR : 1);
  if (spd>limit){ const k = limit/spd; vx*=k; vy*=k; }

  // 摩擦
  if (!up && !dn && !lf && !rt){
    vx *= FRICTION; vy *= FRICTION;
  }

  // ブレーキ更新
  if (braking){
    brakeTimer -= dt;
    if (brakeTimer<=0){ braking=false; }
  } else if (brakeCd>0){
    brakeCd -= dt;
  }

  // 位置更新
  let nx = px + vx*dt, ny = py + vy*dt;

  // 壁衝突（AABBで押し戻し）
  for(const w of walls){
    // X
    if (nx+P_RADIUS > w.x && nx-P_RADIUS < w.x+w.w && ny+P_RADIUS > w.y && ny-P_RADIUS < w.y+w.h){
      // どっち側から入ったか判定
      if (px <= w.x) nx = w.x - P_RADIUS;
      else if (px >= w.x+w.w) nx = w.x+w.w + P_RADIUS;
    }
    // Y
    if (nx+P_RADIUS > w.x && nx-P_RADIUS < w.x+w.w && ny+P_RADIUS > w.y && ny-P_RADIUS < w.y+w.h){
      if (py <= w.y) ny = w.y - P_RADIUS;
      else if (py >= w.y+w.h) ny = w.y+w.h + P_RADIUS;
    }
  }

  // 境界クランプ
  nx = clamp(nx, FIELD_PAD+P_RADIUS, cv.clientWidth - FIELD_PAD - P_RADIUS);
  ny = clamp(ny, FIELD_PAD+P_RADIUS, cv.clientHeight - FIELD_PAD - P_RADIUS);

  // 反映
  px = nx; py = ny;

  // 軌跡記録
  const nowSec = (ts - t0)/1000;
  trail.push({t:nowSec, x:px, y:py});
  // 古いの掃除
  while(trail.length && nowSec - trail[0].t > TRAIL_CAP) trail.shift();

  // ゴースト位置（DELAY前を補間）
  const targetT = nowSec - DELAY;
  if (trail.length && targetT >= trail[0].t){
    // 探す
    let i=1;
    while(i<trail.length && trail[i].t < targetT) i++;
    const a = trail[i-1], b = trail[Math.min(i, trail.length-1)];
    const r = (targetT - a.t) / Math.max(1e-5, b.t - a.t);
    ghost.x = a.x + (b.x - a.x)*clamp(r,0,1);
    ghost.y = a.y + (b.y - a.y)*clamp(r,0,1);
    ghost.ready = true;
  } else {
    ghost.ready = false;
    ghost.x = px; ghost.y = py;
  }

  // コイン取得
  for(const c of coins){
    if (c.taken) continue;
    if (dist(px,py,c.x,c.y) <= P_RADIUS + COIN_R){
      c.taken = true; coinCount++; coinsEl.textContent = coinCount;
    }
  }

  // 失敗判定（ゴースト接触）
  if (ghost.ready && dist(px,py,ghost.x,ghost.y) <= P_RADIUS + G_RADIUS - HIT_FORGIVE){
    fail('ゴーストに触れた…');
    return;
  }

  // クリア判定
  if (coinCount >= TARGET_COINS){
    success();
    return;
  }

  // 描画
  draw(dt);

  raf=requestAnimationFrame(loop);
}

/* ---------- 描画 ---------- */
function draw(dt){
  const W=cv.clientWidth, H=cv.clientHeight;
  ctx.clearRect(0,0,W,H);

  // 背景グリッド
  ctx.strokeStyle='rgba(255,255,255,.06)';
  ctx.lineWidth=1;
  ctx.beginPath();
  for(let x=FIELD_PAD; x<=W-FIELD_PAD; x+=40){ ctx.moveTo(x,FIELD_PAD); ctx.lineTo(x,H-FIELD_PAD); }
  for(let y=FIELD_PAD; y<=H-FIELD_PAD; y+=40){ ctx.moveTo(FIELD_PAD,y); ctx.lineTo(W-FIELD_PAD,y); }
  ctx.stroke();

  // 壁
  ctx.fillStyle='#15253a';
  walls.forEach(w=> ctx.fillRect(w.x,w.y,w.w,w.h));

  // コイン
  coins.forEach(c=>{
    if (c.taken) return;
    ctx.beginPath();
    ctx.arc(c.x,c.y,COIN_R,0,Math.PI*2);
    ctx.fillStyle='#fbbf24';
    ctx.fill();
    ctx.strokeStyle='#fde68a';
    ctx.lineWidth=2;
    ctx.stroke();
  });

  // ゴースト軌跡（薄い線）
  ctx.strokeStyle='rgba(250,204,21,.25)';
  ctx.lineWidth=2;
  ctx.beginPath();
  trail.forEach((p,i)=>{
    if (i===0) ctx.moveTo(p.x,p.y);
    else ctx.lineTo(p.x,p.y);
  });
  ctx.stroke();

  // ゴースト
  if (ghost.ready){
    ctx.beginPath();
    ctx.arc(ghost.x,ghost.y,G_RADIUS,0,Math.PI*2);
    ctx.fillStyle='rgba(248,113,113,.8)';
    ctx.fill();
    ctx.strokeStyle='rgba(239,68,68,1)';
    ctx.lineWidth=2;
    ctx.stroke();
  }

  // プレイヤー
  ctx.beginPath();
  ctx.arc(px,py,P_RADIUS,0,Math.PI*2);
  ctx.fillStyle= braking ? '#60a5fa' : '#22d3ee';
  ctx.fill();
  ctx.strokeStyle= braking ? '#93c5fd' : '#67e8f9';
  ctx.lineWidth=2;
  ctx.stroke();
}

/* ---------- 成否 ---------- */
function fail(reason){
  playing=false;
  ov.style.display='grid';
  ovMsg.textContent='失敗…';
  ovSub.textContent = `${reason}（条件：${TIME_LIMIT}秒以内にコイン${TARGET_COINS}枚）`;
}
function success(){
  playing=false;
  SecretDex.grant(67);
  ov.style.display='grid';
  ovMsg.textContent='解放成功！ #67 が使えるようになった';
  ovSub.textContent='図鑑で選択できます。';
}

/* ---------- ボタン ---------- */
startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);
resetBtn.addEventListener('click', ()=>{
  if (confirm('本当に #67 の解放状態をリセットしますか？')){
    SecretDex.reset(67);
    alert('リセットしました。再挑戦できます。');
  }
});

/* ---------- 初期化 ---------- */
resetGame();
</script>
</body>
</html>
