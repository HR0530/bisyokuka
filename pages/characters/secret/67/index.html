<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>シークレット挑戦 #67：Orbit Switch Arena（激むず）</title>
  <!-- 任意：共通アンロック補助（存在しなくてもOK） -->
  <script src="../_unlock.js" defer></script>
  <style>
    :root{
      --bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;
      --accent:#06b6d4;--ok:#22c55e;--warn:#ef4444;--muted:#9ca3af
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:900px;margin:24px auto;padding:16px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
    .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .btn{background:var(--accent);color:#031a1f;border:none;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
    .btn.ghost{background:#0ea5e9;color:#031423}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .muted{color:var(--muted);text-decoration:none}
    .stats{display:flex;gap:16px;align-items:center}
    .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
    canvas{
      display:block;width:100%;
      height:clamp(320px, calc(100svh - 260px), 640px);
      margin-top:10px;
      background:radial-gradient(1200px 600px at 50% 50%, #0f2238 0%, #0b1626 60%);
      border-radius:12px;border:1px solid #1a2740
    }
    @media (max-width:640px){ canvas{height:360px} }
    .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45)}
    .overlay .sheet{background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;display:grid;gap:10px;justify-items:center}
  </style>
</head>
<body>
<div class="wrap">
  <h1>シークレット挑戦 #67：Orbit Switch Arena（激むず）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">条件：<b>20秒生存</b> ＋ <b>シャード10個</b></span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span>シャード：<b id="shards">0</b>/10</span>
        <span class="muted" id="laneLabel">Lane: Inner</span>
      </div>
      <div class="row" style="gap:10px">
        <button class="btn" id="toggleBtn" aria-label="レーン切替">TOGGLE</button>
        <button class="btn" id="startBtn">START</button>
        <a class="muted" href="../../dex/index.html">← 図鑑へ戻る</a>
      </div>
    </div>

    <canvas id="cv"></canvas>

    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>

  <div class="muted" style="margin-top:8px;line-height:1.6">
    操作：タップ/クリック or <b>SPACE</b> で <b>内外レーン切替</b>（トグル）。<br/>
    赤いアーク（壁）は接触で即死。金のシャードを通過して集めよう。<br/>
    すべての障害は出現前に<b>オレンジ色で予告（0.55秒）</b>されます。フォーカスが外れると一時停止。
  </div>
</div>

<script>
/* ===== アンロック（#67） ===== */
const DEX_KEY     = 'dex_state_v1';
const SECRET_NO   = 67;               // 表示番号
const SECRET_ID   = 66;               // 0-based id（#67 → 66）
const SECRET_FILE = 'secret_67.png';  // project-root に置く

function loadDex(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY)||'{}'); }catch{ return {}; } }
function saveDex(v){ localStorage.setItem(DEX_KEY, JSON.stringify(v||{})); }
function unlock67(){
  // 共通ユーティリティがあれば優先
  if (typeof window.unlockSecret === 'function'){ window.unlockSecret(SECRET_NO, SECRET_FILE); return; }
  if (typeof window.registerSecretFile === 'function'){ window.registerSecretFile(SECRET_ID, SECRET_FILE); }
  // 直接 localStorage を更新
  const dex = loadDex();
  dex.unlocked    = Object.assign({}, dex.unlocked, { [SECRET_ID]: true });
  dex.secretFiles = Object.assign({}, dex.secretFiles, { [String(SECRET_ID)]: SECRET_FILE });
  if (!dex.selected) dex.selected = SECRET_FILE;
  saveDex(dex);
  try{ window.dispatchEvent(new StorageEvent('storage', {key:DEX_KEY, newValue:JSON.stringify(dex)})); }catch(_){}
}

/* ===== Canvas（高DPI） ===== */
const cv  = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', fitCanvas, {passive:true});
fitCanvas();

/* ===== DOM ===== */
const startBtn  = document.getElementById('startBtn');
const toggleBtn = document.getElementById('toggleBtn');
const timeEl    = document.getElementById('time');
const shardsEl  = document.getElementById('shards');
const laneLabel = document.getElementById('laneLabel');
const ov        = document.getElementById('ov');
const ovMsg     = document.getElementById('ovMsg');
const ovSub     = document.getElementById('ovSub');
const retryBtn  = document.getElementById('retryBtn');

/* ===== 難易度ノブ（激むず） ===== */
const TIME_NEED     = 20.0;      // 秒
const SHARDS_NEED   = 10;        // 個
const WARN_TIME     = 0.55;      // 予告時間
const SPAWN_BASE    = 0.9;       // アーク出現間隔
const SPAWN_MIN     = 0.55;
const COIN_BASE     = 0.95;      // シャード出現間隔
const COIN_MIN      = 0.65;
const ARC_W_MIN_DEG = 28;        // アーク幅（度）
const ARC_W_MAX_DEG = 60;
const SPEED_START   = 1.8;       // プレイヤー角速度 rad/s
const SPEED_END     = 2.7;

const R_IN_FR   = 0.30;          // 内外の半径（キャンバス短辺に対する係数）
const R_OUT_FR  = 0.42;
const DOT_R     = 6;             // プレイヤー半径（px）
const COIN_R    = 6;             // シャード半径（px）
const HIT_PAD   = 0.08;          // 角度の許容（rad）~4.5°

/* ===== 状態 ===== */
let playing=false, paused=false, t0=0, last=0, raf=0;
let theta=0;          // プレイヤー角度
let lane=0;           // 0:内, 1:外
let omega=SPEED_START;
let timeNow=0, shards=0;
let spawnT=0, coinT=0;

let arcs=[];   // {lane, a0, a1, t, active}
let coins=[];  // {lane, a, t, taken}

/* ===== 補助 ===== */
const TAU = Math.PI*2;
const deg = d=> d*Math.PI/180;
function angNorm(a){ a%=TAU; return a<0?a+TAU:a; }
function angDiff(a,b){
  let d = Math.abs(angNorm(a)-angNorm(b)); return Math.min(d, TAU-d);
}
function inArc(a, a0, a1){
  a = angNorm(a); a0 = angNorm(a0); a1 = angNorm(a1);
  if (a0<=a1) return a>=a0 && a<=a1;
  return a>=a0 || a<=a1; // wrap
}
function center(){ return {cx: cv.clientWidth/2, cy: cv.clientHeight/2}; }
function radii(){
  const s = Math.min(cv.clientWidth, cv.clientHeight);
  return {rin: s*R_IN_FR, rout: s*R_OUT_FR};
}

/* ===== リセット ===== */
function resetGame(){
  cancelAnimationFrame(raf);
  playing=false; paused=false;
  theta=0; lane=0; omega=SPEED_START;
  timeNow=0; shards=0; spawnT=0; coinT=0;
  arcs.length=0; coins.length=0;
  timeEl.textContent='0.0'; shardsEl.textContent='0';
  laneLabel.textContent='Lane: Inner';
  ov.style.display='none';
  drawScene();
}

/* ===== スポーン ===== */
function spawnArc(){
  const L = Math.random()<0.5?0:1;
  const w = deg(ARC_W_MIN_DEG + Math.random()*(ARC_W_MAX_DEG-ARC_W_MIN_DEG));
  const a0 = Math.random()*TAU;
  const a1 = a0 + w;
  arcs.push({lane:L, a0, a1, t:0, active:false});
}
function spawnCoin(){
  const L = Math.random()<0.5?0:1;
  const a = Math.random()*TAU;
  coins.push({lane:L, a, t:0, taken:false});
}

/* ===== 入力 ===== */
function toggleLane(){
  if (!playing || paused) return;
  lane = lane?0:1;
  laneLabel.textContent = lane? 'Lane: Outer' : 'Lane: Inner';
}
toggleBtn.addEventListener('pointerdown', toggleLane, {passive:true});
cv.addEventListener('pointerdown', toggleLane, {passive:true});
addEventListener('keydown', (e)=>{
  if (e.code==='Space'){ e.preventDefault(); toggleLane(); }
});

/* ===== 一時停止（タブ非表示） ===== */
addEventListener('visibilitychange', ()=>{ if (playing) paused = document.hidden; });

/* ===== ループ ===== */
function loop(ts){
  if (!playing) return;
  if (!last) last = ts;
  const dt = Math.min(0.033, (ts-last)/1000); last = ts; // フリーズ保険
  if (paused){ raf = requestAnimationFrame(loop); return; }

  timeNow = (ts - t0)/1000; timeEl.textContent = timeNow.toFixed(1);

  const k = Math.min(1, timeNow/TIME_NEED);
  omega = SPEED_START + (SPEED_END - SPEED_START)*k;

  theta = angNorm(theta + omega*dt);

  // スポーン間隔を詰める
  const arcInt  = Math.max(SPAWN_MIN,  SPAWN_BASE  - 0.02*timeNow);
  const coinInt = Math.max(COIN_MIN,   COIN_BASE   - 0.02*timeNow);
  spawnT += dt; coinT += dt;
  if (spawnT >= arcInt){ spawnT=0; spawnArc(); }
  if (coinT  >= coinInt){ coinT=0; spawnCoin(); }

  // アーク状態遷移
  for (const a of arcs){
    a.t += dt;
    if (!a.active && a.t >= WARN_TIME){ a.active = true; }
  }

  // 衝突（アーク）
  for (const a of arcs){
    if (a.lane !== lane || !a.active) continue;
    if (inArc(theta, a.a0 - HIT_PAD, a.a1 + HIT_PAD)){
      fail('赤アークに接触…');
      return;
    }
  }

  // コイン取得
  for (const c of coins){
    if (c.taken || c.lane !== lane) continue;
    if (angDiff(theta, c.a) <= HIT_PAD){
      c.taken = true; shards++; shardsEl.textContent = shards;
    }
    c.t += dt;
  }

  // 掃除（画面外という概念はないので寿命管理してもよいが、数を抑える）
  if (arcs.length > 60)  arcs.splice(0, arcs.length-60);
  if (coins.length > 30) coins.splice(0, coins.length-30);

  // 描画
  drawScene();

  // クリア判定
  if (timeNow >= TIME_NEED && shards >= SHARDS_NEED){ success(); return; }

  raf = requestAnimationFrame(loop);
}

/* ===== 描画 ===== */
function drawScene(){
  const w = cv.clientWidth, h=cv.clientHeight;
  const {cx, cy} = center();
  const {rin, rout} = radii();

  ctx.clearRect(0,0,w,h);

  // 背景のリング
  ctx.strokeStyle = '#0e243a'; ctx.lineWidth = 10;
  ctx.beginPath(); ctx.arc(cx,cy, rin, 0, TAU);  ctx.stroke();
  ctx.beginPath(); ctx.arc(cx,cy, rout,0, TAU);  ctx.stroke();

  // アーク（予告→オレンジ / 発動→赤）
  for (const a of arcs){
    ctx.lineWidth = (a.lane?10:10);
    ctx.strokeStyle = a.active ? '#ef4444' : '#f59e0b';
    const r = a.lane? rout : rin;
    ctx.beginPath(); ctx.arc(cx,cy, r, a.a0, a.a1); ctx.stroke();
  }

  // コイン
  for (const c of coins){
    if (c.taken) continue;
    const r = c.lane? rout : rin;
    const x = cx + Math.cos(c.a)*r;
    const y = cy + Math.sin(c.a)*r;
    ctx.beginPath(); ctx.arc(x,y, COIN_R, 0, TAU); ctx.closePath();
    ctx.fillStyle = '#fbbf24'; ctx.fill();
    ctx.strokeStyle = '#fde68a'; ctx.lineWidth = 2; ctx.stroke();
  }

  // プレイヤー
  const pr = lane? rout : rin;
  const px = cx + Math.cos(theta)*pr;
  const py = cy + Math.sin(theta)*pr;
  ctx.beginPath(); ctx.arc(px,py, DOT_R, 0, TAU); ctx.closePath();
  ctx.fillStyle = '#22d3ee'; ctx.fill();

  // 角度ガイド（薄）
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.beginPath(); ctx.moveTo(cx,cy);
  ctx.lineTo(cx + Math.cos(theta)*rout, cy + Math.sin(theta)*rout);
  ctx.stroke();
}

/* ===== 成否 ===== */
function fail(msg){
  playing=false;
  ovMsg.textContent = '失敗…';
  ovSub.textContent = `${msg}（条件：${TIME_NEED.toFixed(0)}秒＆シャード${SHARDS_NEED}）`;
  ov.style.display = 'grid';
}
function success(){
  playing=false;
  unlock67();
  ovMsg.textContent = '解放成功！ #67 が使えるようになった';
  ovSub.textContent = '図鑑で選択できます。';
  ov.style.display = 'grid';
}

/* ===== 開始・再試行 ===== */
function start(){
  resetGame();
  playing=true; paused=false;
  t0 = performance.now(); last = t0;
  // 開幕はアーク無しのちょい余白
  spawnT = 0.4; coinT = 0.2;
  raf = requestAnimationFrame(loop);
}
startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);

/* 初期化 */
resetGame();
</script>
</body>
</html>
