<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Secret #67：Ghost Chase（easier tweak）</title>
<style>
  :root{--bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;--accent:#f59e0b;--muted:#94a3b8}
  *{box-sizing:border-box}
  html,body{height:100%; overscroll-behavior:none;}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui}
  .wrap{max-width:960px;margin:24px auto;padding:16px}
  .panel{position:relative;background:var(--card);border:1px solid #223047;border-radius:14px;padding:12px}
  .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .stats{display:flex;gap:14px;align-items:center}
  .badge{background:#0b1626;border:1px solid #1b2944;border-radius:999px;padding:6px 10px;font-weight:800}
  .muted{color:var(--muted);text-decoration:none}
  .btn{background:var(--accent);color:#1a1204;border:none;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer}
  .btn.ghost{background:#0ea5e9;color:#031423}
  canvas{
    display:block;width:100%;
    height:clamp(360px, calc(100svh - 260px), 700px);
    margin-top:8px;border-radius:12px;border:1px solid #1a2740;background:#0a1523;
    touch-action:none; outline:none;
  }
  @media (max-width:640px){ canvas{height:420px} }
  .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.5)}
  .sheet{background:#111827;border:1px solid #243042;border-radius:14px;padding:18px;min-width:60%;display:grid;gap:10px;justify-items:center}
  .hud-right{position:absolute;right:10px;top:10px;display:flex;gap:8px}
  .mini{background:#0b1626;border:1px solid #1b2944;border-radius:10px;color:#e5e7eb;padding:6px 10px;font-weight:700;cursor:pointer}
</style>
</head>
<body>
<div class="wrap">
  <h1>Secret #67：Ghost Chase（ちょい易しめ）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">条件：<b>22秒 生存</b></span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span>残像：<b id="echoes">0</b>/3</span>
      </div>
      <!-- 変更後（margin-rightで“少し左”へ） -->
      <div class="row" style="gap:8px; margin-right:16px">
      <button class="btn" id="startBtn">START</button>
      <a class="muted" href="../../dex/index.html">← 図鑑へ戻る</a>
    </div>
    </div>

    <div class="hud-right">
      <button class="mini" id="dashBtn" title="タップでもダッシュ">DASH</button>
    </div>

    <!-- フォーカス可能にしてキーボード操作を奪う -->
    <canvas id="cv" tabindex="0"></canvas>

    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:900;font-size:18px"></div>
        <div id="ovSub" class="muted"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>
  <p class="muted" style="margin-top:8px">
    操作：<b>WASD / 方向キー</b>で移動、<b>Space / DASH</b>でダッシュ（短距離・クールダウン有）。<br/>
    2体目のゴースト・残像は後半から出現。視界は徐々に狭くなります。
  </p>
</div>

<script>
/* ===== SecretDex（保存/解放） ===== */
const DEX_KEY='dex_state_v1', SID=67, ID=SID-1, FILE=`secret_${SID}.png`;
const SecretDex = {
  load(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY)||'{}'); }catch{ return {}; } },
  save(v){ localStorage.setItem(DEX_KEY, JSON.stringify(v||{})); },
  grant(no=SID){
    const id=(no|0)-1, file=`secret_${no}.png`;
    const dex=this.load();
    dex.unlocked = dex.unlocked || {};
    dex.secretFiles = dex.secretFiles || {};
    dex.unlocked[id]=true;
    dex.secretFiles[String(id)]=file;
    if(!dex.selected) dex.selected=file;
    this.save(dex);
    try{ window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)})); }catch(_){}
  }
};

/* ===== Canvas 高DPI ===== */
const cv=document.getElementById('cv');
const ctx=cv.getContext('2d');
function fitCanvas(){
  const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w=cv.clientWidth, h=cv.clientHeight;
  cv.width=Math.floor(w*dpr); cv.height=Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', fitCanvas, {passive:true}); fitCanvas();

/* ===== DOM ===== */
const startBtn=document.getElementById('startBtn');
const dashBtn=document.getElementById('dashBtn');
const timeEl=document.getElementById('time');
const echoesEl=document.getElementById('echoes');
const ov=document.getElementById('ov');
const ovMsg=document.getElementById('ovMsg');
const ovSub=document.getElementById('ovSub');
const retryBtn=document.getElementById('retryBtn');

/* ===== ちょい易しめパラメータ ===== */
const TIME_NEED   = 22.0;
const ARENA_PAD   = 24;
const P_SPEED     = 225;     // ↑
const DASH_SPEED  = 560;
const DASH_TIME   = 0.19;    // ↑少し長め
const DASH_CD     = 0.42;    // ↓短め

const G1_BASE=150, G1_END=245;     // ↓弱め
const G2_SPAWN_T=13.5;             // ↓遅め
const G2_BASE=135, G2_END=230;     // ↓弱め

const TELEPORT_INT1=[5.8,8.2];     // ↓テレポ頻度やや減
const TELEPORT_INT2=[6.6,9.0];
const TELEPORT_DIST=[160,320];     // ↑遠め
const TELEP_FLASH=0.20;

const ECHO_MAX=3;
const ECHO_DELAY=0.28;
const ECHO_SPAWN_T1=10.0, ECHO_SPAWN_T2=16.5, ECHO_SPAWN_T3=21.0; // ↓遅め
const LANTERN_MAX=210, LANTERN_MIN=140; // ↑視界広め
const HURT_R=12;                        // ↓当たり判定ゆるめ

/* ===== 状態 ===== */
let playing=false, last=0, t0=0, raf=0, timeNow=0;
let px=0, py=0, vx=0, vy=0, dashT=0, dashCD=0;
let keys=new Set();
let ghosts=[], echoes=[], trail=[], trailAcc=0;

/* ===== スクロール抑止（矢印/Space） ===== */
function blockScrollKeys(e){
  const k=e.key||e.code;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Space'].includes(k)){
    e.preventDefault();
  }
}
document.addEventListener('keydown', blockScrollKeys, {capture:true});

/* ===== 入力 ===== */
addEventListener('keydown', e=>{
  if(e.repeat) return;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD',' '].includes(e.code)) e.preventDefault();
  if(e.code==='Space'){ dash(); return; }
  keys.add(e.code);
});
addEventListener('keyup', e=> keys.delete(e.code));
dashBtn.addEventListener('click', dash);

cv.addEventListener('pointerdown', e=>{
  const rect=cv.getBoundingClientRect();
  const tx=e.clientX-rect.left, ty=e.clientY-rect.top;
  const dx=tx-px, dy=ty-py; const L=Math.hypot(dx,dy)||1;
  vx=(dx/L)*P_SPEED; vy=(dy/L)*P_SPEED;
  dash();
},{passive:true});

/* ===== 主要ロジック ===== */
function resetGame(){
  cancelAnimationFrame(raf);
  playing=false; timeNow=0; last=0; t0=0;
  const w=cv.clientWidth, h=cv.clientHeight;
  px=w/2; py=h/2; vx=0; vy=0; dashT=0; dashCD=0;
  ghosts.length=0; echoes.length=0; trail.length=0; trailAcc=0; keys.clear();
  spawnGhost(1); scheduleTeleport(ghosts[0], TELEPORT_INT1);
  timeEl.textContent='0.0'; echoesEl.textContent='0';
  ov.style.display='none';
  drawScene(currentLanternR(), 0);
}
function start(){
  resetGame();
  playing=true;
  t0=performance.now(); last=t0;
  // フォーカスをキャンバスへ → 矢印スクロール完全抑止
  cv.focus({preventScroll:true});
  raf=requestAnimationFrame(loop);
}
function succeed(){
  playing=false;
  SecretDex.grant(SID);
  ovMsg.textContent='解放成功！ #67';
  ovSub.textContent='図鑑で選択できます。';
  ov.style.display='grid';
}
function fail(reason='捕まった…'){
  playing=false;
  ovMsg.textContent='失敗…';
  ovSub.textContent=`${reason}（22秒生存でクリア）`;
  ov.style.display='grid';
}

/* ===== ゴースト/残像 ===== */
function spawnGhost(no){
  ghosts.push({
    no, x: px+(Math.random()<0.5?-1:1)*160, y: py+(Math.random()<0.5?-1:1)*160,
    spd: no===1?G1_BASE:G2_BASE, telAt:0, flashT:0
  });
}
function scheduleTeleport(g, range){ const [a,b]=range; g.telAt=timeNow+(a+Math.random()*(b-a)); }
function teleportGhost(g){
  g.flashT=TELEP_FLASH;
  const dist=TELEPORT_DIST[0]+Math.random()*(TELEPORT_DIST[1]-TELEPORT_DIST[0]);
  const ang=Math.atan2(vy||0, vx||0) + (Math.PI*(0.8+Math.random()*0.4));
  const tx=clamp(px+Math.cos(ang)*dist, 24, cv.clientWidth-24);
  const ty=clamp(py+Math.sin(ang)*dist, 24, cv.clientHeight-24);
  g.x=tx; g.y=ty;
  scheduleTeleport(g, g.no===1?TELEPORT_INT1:TELEPORT_INT2);
}

/* ===== ループ ===== */
function loop(ts){
  if(!playing) return;
  const dt=(ts-last)/1000; last=ts;
  timeNow=(ts-t0)/1000; timeEl.textContent=timeNow.toFixed(1);

  if(ghosts.length===1 && timeNow>=G2_SPAWN_T){ spawnGhost(2); scheduleTeleport(ghosts[1], TELEPORT_INT2); }

  const k=Math.min(1, timeNow/TIME_NEED);
  const lanternR=currentLanternR();

  // 入力
  let ax=0, ay=0;
  if(keys.has('ArrowUp')||keys.has('KeyW')) ay-=1;
  if(keys.has('ArrowDown')||keys.has('KeyS')) ay+=1;
  if(keys.has('ArrowLeft')||keys.has('KeyA')) ax-=1;
  if(keys.has('ArrowRight')||keys.has('KeyD')) ax+=1;
  const L=Math.hypot(ax,ay);

  if(dashT>0){ dashT-=dt; }
  else{
    if(L>0){ vx=(ax/L)*P_SPEED; vy=(ay/L)*P_SPEED; }
    else { vx*=0.86; vy*=0.86; }
  }
  px=clamp(px+vx*dt, 24, cv.clientWidth-24);
  py=clamp(py+vy*dt, 24, cv.clientHeight-24);

  // 軌跡と残像
  trailAcc+=dt;
  if(trailAcc>=ECHO_DELAY){ trailAcc=0; trail.unshift({x:px,y:py}); if(trail.length>Math.round((TIME_NEED+5)/ECHO_DELAY)) trail.pop(); }
  if(timeNow>=ECHO_SPAWN_T1 && echoes.length<1) makeEcho(0.85);
  if(timeNow>=ECHO_SPAWN_T2 && echoes.length<2) makeEcho(0.9);
  if(timeNow>=ECHO_SPAWN_T3 && echoes.length<3) makeEcho(0.95);
  echoesEl.textContent=echoes.length;

  // ゴースト追跡
  for(const g of ghosts){
    const target=predictTarget();
    const base=g.no===1?G1_BASE:G2_BASE, end=g.no===1?G1_END:G2_END;
    g.spd=base+(end-base)*k;
    if(timeNow>=g.telAt) teleportGhost(g); else if(g.flashT>0) g.flashT-=dt;
    const dx=target.x-g.x, dy=target.y-g.y, len=Math.hypot(dx,dy)||1;
    g.x+=dx/len*g.spd*dt; g.y+=dy/len*g.spd*dt;
  }

  // 残像追尾
  for(const e of echoes){
    if(e.idx<e.trail.length-1){
      const p=e.trail[e.idx], dx=p.x-e.x, dy=p.y-e.y, len=Math.hypot(dx,dy)||1, step=e.spd*dt;
      if(len<=step){ e.x=p.x; e.y=p.y; e.idx++; } else { e.x+=dx/len*step; e.y+=dy/len*step; }
    }
  }

  // 当たり判定
  for(const g of ghosts){ if(dist(px,py,g.x,g.y)<=HURT_R){ fail(); return; } }
  for(const e of echoes){ if(dist(px,py,e.x,e.y)<=HURT_R*0.9){ fail('過去の自分に捕まった…'); return; } }

  if(timeNow>=TIME_NEED){ succeed(); return; }

  drawScene(lanternR, k);
  raf=requestAnimationFrame(loop);
}

/* ===== 補助 ===== */
function dash(){
  if(dashT>0||dashCD>0) return;
  dashT=DASH_TIME; dashCD=DASH_CD;
  const L=Math.hypot(vx,vy);
  let ux=1, uy=0;
  if(L>0){ ux=vx/L; uy=vy/L; } else { const a=Math.random()*Math.PI*2; ux=Math.cos(a); uy=Math.sin(a); }
  vx=ux*DASH_SPEED; vy=uy*DASH_SPEED;
  const id=setInterval(()=>{ dashCD-=0.05; if(dashCD<=0){ dashCD=0; clearInterval(id); } },50);
}
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }
function predictTarget(){
  const look=0.16+Math.min(0.28, timeNow*0.01);
  return { x:clamp(px+vx*look,24,cv.clientWidth-24), y:clamp(py+vy*look,24,cv.clientHeight-24) };
}
function makeEcho(slow=1.0){
  const eTrail=trail.slice().reverse();
  const start=eTrail[0]||{x:px,y:py};
  echoes.push({x:start.x,y:start.y,trail:eTrail,idx:0,spd:P_SPEED*slow});
}
function currentLanternR(){
  const k=Math.min(1, timeNow/TIME_NEED);
  return LANTERN_MAX + (LANTERN_MIN - LANTERN_MAX)*k;
}

/* ===== 描画 ===== */
function drawScene(lanternR, k){
  const w=cv.clientWidth, h=cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景グリッド
  const drift=(timeNow*36)%40;
  ctx.fillStyle='#0f2338';
  for(let y=24;y<h-24;y+=40){ ctx.fillRect(24, Math.floor(y+drift)%h, w-48, 1); }
  for(let x=24;x<w-24;x+=40){ ctx.fillRect(Math.floor(x+drift)%w, 24, 1, h-48); }
  ctx.strokeStyle='#162a44'; ctx.lineWidth=2; ctx.strokeRect(24,24,w-48,h-48);

  // 残像
  for(const e of echoes){ ctx.fillStyle='rgba(250,204,21,0.85)'; ctx.beginPath(); ctx.arc(e.x,e.y,7,0,Math.PI*2); ctx.fill(); }

  // ゴースト
  for(const g of ghosts){
    if(g.flashT>0){ ctx.strokeStyle='rgba(239,68,68,0.8)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(g.x,g.y,18,0,Math.PI*2); ctx.stroke(); }
    ctx.fillStyle='rgba(239,68,68,0.28)'; ctx.beginPath(); ctx.arc(g.x,g.y,20,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='rgba(239,68,68,0.92)'; ctx.beginPath(); ctx.arc(g.x,g.y,10,0,Math.PI*2); ctx.fill();
  }

  // プレイヤー
  ctx.fillStyle='#22d3ee'; ctx.beginPath(); ctx.arc(px,py,8,0,Math.PI*2); ctx.fill();
  if(dashT>0){ ctx.strokeStyle='rgba(34,211,238,.6)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(px,py,14,0,Math.PI*2); ctx.stroke(); }

  // 視界
  const grd=ctx.createRadialGradient(px,py, Math.max(10,lanternR*0.35), px,py, lanternR);
  grd.addColorStop(0,'rgba(0,0,0,0)'); grd.addColorStop(1,'rgba(0,0,0,0.84)');
  ctx.fillStyle=grd; ctx.fillRect(0,0,w,h);
}

/* ===== 起動 ===== */
startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);
resetGame();
</script>
</body>
</html>
