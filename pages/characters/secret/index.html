<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>シークレット挑戦：Hell Coin Runner</title>
<style>
  :root{
    --bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;
    --accent:#f59e0b;--ok:#22c55e;--warn:#ef4444;--muted:#9ca3af
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:900px;margin:24px auto;padding:16px}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px}
  .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .btn{
    background:var(--accent);color:#221a05;border:none;border-radius:10px;
    padding:10px 14px;font-weight:800;cursor:pointer
  }
  .btn.ghost{background:#0ea5e9;color:#031423}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .muted{color:var(--muted);text-decoration:none}
  .stats{display:flex;gap:16px;align-items:center}
  .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
  canvas{
    display:block;width:100%;
    height:clamp(320px, calc(100svh - 260px), 640px);
    margin-top:10px;
    background:linear-gradient(#0f2238,#0b1626);
    border-radius:12px;border:1px solid #1a2740
  }

  @media (max-width:640px){ canvas{height:360px} }
  .overlay{
    position:absolute;inset:0;display:none;place-items:center;
    background:rgba(0,0,0,.45)
  }
  .overlay .sheet{
    background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;
    display:grid;gap:10px;justify-items:center
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>シークレット挑戦：Hell Coin Runner（激むず）</h1>
  <div class="panel" style="position:relative">
    <div class="row">
      <div class="stats">
        <span class="badge">条件：20秒生存 ＋ コイン12枚</span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span>コイン：<b id="coins">0</b>/12</span>
      </div>
      <div class="row" style="gap:10px">
        <button class="btn" id="startBtn">START</button>
        <a class="muted" href="../dex/index.html">← 図鑑へ戻る</a>
      </div>
    </div>
    <canvas id="cv"></canvas>

    <!-- 失敗・成功オーバーレイ -->
    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>
  <div class="muted" style="margin-top:8px">
    操作：タップ/クリック or <b>SPACE</b> でジャンプ（2段ジャンプ可）。  
    フォーカスを外すと一時停止します。
  </div>
</div>

<script>
/* ====== ストレージ（#65解放のみを更新） ====== */
const DEX_KEY     = 'dex_state_v1';
const SECRET65_ID = 64;              // 0始まり → #65
const SECRET_FILE = 'secret_65.png'; // project-root に用意してね

function loadDex(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY)||'{}'); }catch{ return {}; } }
function saveDex(v){ localStorage.setItem(DEX_KEY, JSON.stringify(v||{})); }
function grantSecret65(){
  const dex = loadDex();
  dex.unlocked = Object.assign({}, dex.unlocked, { [SECRET65_ID]: true });
  dex.secret65 = SECRET_FILE;
  if (!dex.selected) dex.selected = SECRET_FILE;
  saveDex(dex);
  // 同一オリジンなら他タブへも伝播
  try{ window.dispatchEvent(new StorageEvent('storage', {key:DEX_KEY, newValue:JSON.stringify(dex)})); }catch(_){}
}

/* ====== Canvas 準備（高DPI対応） ====== */
const cv  = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', fitCanvas, {passive:true});
fitCanvas();

/* ====== DOM ====== */
const startBtn = document.getElementById('startBtn');
const timeEl   = document.getElementById('time');
const coinsEl  = document.getElementById('coins');
const ov       = document.getElementById('ov');
const ovMsg    = document.getElementById('ovMsg');
const ovSub    = document.getElementById('ovSub');
const retryBtn = document.getElementById('retryBtn');

/* ====== ゲーム定数（激むず） ====== */
const GROUND_H   = 28;
const PLAYER_W   = 22, PLAYER_H = 26;
const GRAVITY    = 1100;      // px/s^2
const JUMP_V     = -430;      // 1段目
const DJUMP_V    = -420;      // 2段目（少し弱い）
const COINS_NEED = 12;
const TIME_NEED  = 20.0;      // 秒
const START_SPD  = 340;       // px/s
const END_SPD    = 560;       // 20s 後の速度
const SPAWN_BASE = 0.85;      // 初期出現間隔（秒）
const SPAWN_MIN  = 0.55;      // 最短
const HIT_FORGIVE= 2;         // 当たり判定のゆるみ（px）
const MAX_JUMPS = 3; // ← ここを 3 や 4 にすれば多段ジャンプ化


/* ====== 状態 ====== */
let playing=false, t0=0, last=0, raf=0, paused=false, pausedDur=0;
let speed=START_SPD, spawnTimer=0;
let px=90, py=0, vy=0, onGround=false, jumpsLeft=MAX_JUMPS, coyote=0;
let obstacles=[], coins=[], timeNow=0, coinCount=0;

function groundY(){ return cv.clientHeight - GROUND_H; }

/* ====== リセット ====== */
function resetGame(){
  cancelAnimationFrame(raf);
  playing=false; paused=false; pausedDur=0;
  speed=START_SPD; spawnTimer=0; timeNow=0; coinCount=0;
  px=90; py=groundY()-PLAYER_H; vy=0; onGround=true; jumpsLeft=MAX_JUMPS; coyote=0;
  obstacles.length=0; coins.length=0;
  timeEl.textContent='0.0'; coinsEl.textContent='0';
  ctx.clearRect(0,0,cv.clientWidth,cv.clientHeight);
  drawScene(0);
  ov.style.display='none';
}

/* ====== スポーン（障害物＆コイン） ====== */
function spawnPack(){
  const h = groundY();
  const roll = Math.random();
  if (roll < 0.45){
    // ─ スパイク列（低いが幅広）
    const w = 28 + Math.random()*20;
    obstacles.push({x:cv.clientWidth+40, y:h-16, w,  h:16, type:'spike'});
    // コインを低めに1〜2
    const c = 1 + (Math.random()<0.5?1:0);
    for(let i=0;i<c;i++){
      coins.push({x: cv.clientWidth+60 + i*28, y:h-48, r:8, taken:false});
    }
  }else if(roll < 0.8){
    // ─ 壁（中〜高・幅広）＋ジャンプ強要
    const w = 24 + Math.random()*24;
    const hh= 40 + Math.random()*90;
    obstacles.push({x:cv.clientWidth+40, y:h-hh, w,  h:hh, type:'wall'});
    // 壁上にコイン（1〜2個）
    const c = 1 + (Math.random()<0.5?1:0);
    for(let i=0;i<c;i++){
      coins.push({x: cv.clientWidth+40 + w/2 + i*24, y:h-hh-26, r:8, taken:false});
    }
  }else{
    // ─ ドローン（空中移動）
    const baseY = h - (70 + Math.random()*110);
    const amp   = 24 + Math.random()*18;
    obstacles.push({x:cv.clientWidth+40, y:baseY, w:28, h:18, type:'drone', baseY, amp, t:0});
    // ドローンの上下にコイン
    coins.push({x: cv.clientWidth+80, y:baseY-24, r:8, taken:false});
    coins.push({x: cv.clientWidth+110, y:baseY+24, r:8, taken:false});
  }
}

/* ====== 入力（ジャンプ） ====== */
function jump(){
  if (!playing || paused) return;

  // 地上 or コヨーテ なら 1段目としてカウントを満タン-1 に
  if (onGround || coyote > 0){
    vy = JUMP_V;
    onGround = false;
    coyote = 0;
    jumpsLeft = Math.max(0, MAX_JUMPS - 1);
    return;
  }

  // 空中なら残り回数だけ追加ジャンプ可能
  if (jumpsLeft > 0){
    vy = DJUMP_V;
    jumpsLeft -= 1;
  }
}

/* モバイル：キャンバス押下でジャンプ */
cv.addEventListener('pointerdown', jump, {passive:true});
/* PC：Space */
window.addEventListener('keydown', (e)=>{
  if (e.code==='Space'){ e.preventDefault(); jump(); }
});

/* タブ非表示時は一時停止扱い */
document.addEventListener('visibilitychange', ()=>{
  if (!playing) return;
  if (document.hidden){
    paused = true;
  }else{
    paused = false;
  }
});

/* ====== ループ ====== */
function loop(ts){
  if (!playing) return;
  if (!last) last = ts;
  let dt = (ts - last)/1000;
  last = ts;
  if (paused){ raf = requestAnimationFrame(loop); return; }

  timeNow = (ts - t0)/1000;
  timeEl.textContent = timeNow.toFixed(1);

  // 加速（20sで END_SPD）
  const k = Math.min(1, timeNow/20);
  speed = START_SPD + (END_SPD - START_SPD)*k;

  // スポーン間隔を詰める
  const spawnInt = Math.max(SPAWN_MIN, SPAWN_BASE - 0.02*timeNow);
  spawnTimer += dt;
  if (spawnTimer >= spawnInt){
    spawnTimer = 0;
    spawnPack();
  }

  // 物理
  vy += GRAVITY*dt;
  py += vy*dt;

  const gy = groundY() - PLAYER_H;
  if (py >= gy){
  py = gy; vy = 0;
  if(!onGround){
  onGround = true;
  jumpsLeft = MAX_JUMPS;   // ← 常に最大回数まで回復
  　 }
   }
  else { onGround=false; coyote = Math.max(0, coyote - dt); }

  // 前進
  const vx = speed*dt;
  obstacles.forEach(o=>{
    o.x -= vx;
    if (o.type==='drone'){ o.t += dt; o.y = o.baseY + Math.sin(o.t*4)*o.amp; }
  });
  coins.forEach(c=> c.x -= vx);

  // 衝突（プレイヤー矩形）
  const pr = {x:px, y:py, w:PLAYER_W, h:PLAYER_H};

  // コイン
  for (const c of coins){
    if (c.taken) continue;
    const dx = Math.abs((c.x) - (pr.x + pr.w/2));
    const dy = Math.abs((c.y) - (pr.y + pr.h/2));
    if (dx < (pr.w/2 + c.r) && dy < (pr.h/2 + c.r)){
      c.taken = true; coinCount++; coinsEl.textContent = coinCount;
    }
  }

  // 障害物
  for (const o of obstacles){
    if (o.x > pr.x + pr.w || o.x + o.w < pr.x) continue;
    const overlapX = !(pr.x + pr.w - HIT_FORGIVE < o.x || pr.x + HIT_FORGIVE > o.x + o.w);
    const overlapY = !(pr.y + pr.h - HIT_FORGIVE < o.y || pr.y + HIT_FORGIVE > o.y + o.h);
    if (overlapX && overlapY){
      fail(`障害物に当たった…`);
      return;
    }
  }

  // 画面外掃除
  obstacles = obstacles.filter(o=> o.x + o.w > -40);
  coins     = coins.filter(c=> !c.taken && c.x > -40);

  // 描画
  drawScene(dt);

  // クリア条件
  if (timeNow >= TIME_NEED && coinCount >= COINS_NEED){
    success();
    return;
  }

  raf = requestAnimationFrame(loop);
}

/* ====== 描画 ====== */
function drawScene(dt){
  const w = cv.clientWidth, h=cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景パルス
  const t = timeNow || 0;
  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0, `rgba(15,34,56,1)`);
  grad.addColorStop(1, `rgba(11,22,38,1)`);
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,w,h);

  // 地面
  ctx.fillStyle = '#0e243a';
  ctx.fillRect(0, h-GROUND_H, w, GROUND_H);

  // コイン
  for (const c of coins){
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
    ctx.closePath();
    ctx.fillStyle = '#fbbf24';
    ctx.fill();
    ctx.strokeStyle = '#fde68a';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // 障害物
  for (const o of obstacles){
    if (o.type==='drone'){
      // のこぎりっぽい
      ctx.save();
      ctx.translate(o.x + o.w/2, o.y + o.h/2);
      ctx.rotate((t*6) % (Math.PI*2));
      ctx.fillStyle = '#ef4444';
      for(let i=0;i<8;i++){
        ctx.rotate(Math.PI/4);
        ctx.beginPath();
        ctx.moveTo(0,0); ctx.lineTo(0,-12); ctx.lineTo(8,-8); ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }else if(o.type==='spike'){
      ctx.fillStyle = '#ef4444';
      ctx.beginPath();
      ctx.moveTo(o.x, o.y+o.h);
      ctx.lineTo(o.x+o.w, o.y+o.h);
      ctx.lineTo(o.x+o.w*0.5, o.y);
      ctx.closePath();
      ctx.fill();
    }else{
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(o.x, o.y, o.w, o.h);
    }
  }

  // プレイヤー
  ctx.fillStyle = '#22d3ee';
  ctx.fillRect(px, py, PLAYER_W, PLAYER_H);

  // ガイド（ヒットライン）
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.beginPath(); ctx.moveTo(px+PLAYER_W/2, 0); ctx.lineTo(px+PLAYER_W/2, h); ctx.stroke();
}

/* ====== 成否 ====== */
function fail(msg){
  playing=false;
  ovMsg.textContent = '失敗…';
  ovSub.textContent = msg + '（条件：20秒＆コイン12）';
  ov.style.display = 'grid';
}
function success(){
  playing=false;
  grantSecret65();
  ovMsg.textContent = '解放成功！ #65 が使えるようになった';
  ovSub.textContent = '図鑑で選択できます。';
  ov.style.display = 'grid';
}

/* ====== 開始・再試行 ====== */
function start(){
  resetGame();
  playing=true;
  t0 = performance.now(); last = t0; paused=false;
  // コヨーテタイムは地面を離れて100ms
  coyote = 0.0;
  // 先頭に少しだけウォームアップ空間
  spawnTimer = 0.3;
  raf = requestAnimationFrame(loop);
}

startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);

/* 初期化 */
resetGame();
</script>
</body>
</html>
