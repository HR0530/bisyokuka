<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>挑戦モード – 激ムズランナー</title>
<style>
  :root{
    --bg:#0b1220; --ink:#e5e7eb; --card:#111827; --line:#243042; --accent:#10b981;
    --muted:#9ca3af; --bad:#ef4444; --good:#22c55e;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui, -apple-system, "Segoe UI", Roboto}
  .wrap{max-width:960px;margin:24px auto;padding:16px}
  h1{margin:0 0 10px}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .between{justify-content:space-between}
  .btn{background:var(--accent);color:#052017;border:none;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .pill{background:#0b1626;border:1px solid #1a2640;border-radius:999px;padding:6px 10px;font-weight:700}
  .muted{color:var(--muted);text-decoration:none}
  .board{position:relative;margin-top:10px}
  canvas{
    display:block;width:100%;
    height:clamp(300px, 56vh, 540px); /* 画面に収めつつ大きめに */
    background:radial-gradient(ellipse at 30% 20%, #0f2238 0%, #0b1626 60%);
    border-radius:12px;border:1px solid #1a2740;
  }
  .overlay{
    position:absolute; inset:0; display:grid; place-items:center;
    background:rgba(0,0,0,.35); backdrop-filter: blur(1px);
    border-radius:12px; border:1px solid transparent;
    opacity:0; pointer-events:none; transition:opacity .2s ease;
  }
  .overlay.show{opacity:1; pointer-events:auto}
  .sheet{background:#0e1726;border:1px solid #213146;padding:14px 16px;border-radius:12px;max-width:92%;text-align:center}
  .sheet h2{margin:0 0 6px}
  .sheet p{margin:6px 0 0;color:var(--muted)}
  .result{font-weight:800;margin-top:8px}
  .good{color:var(--good)} .bad{color:var(--bad)}
</style>
</head>
<body>
<div class="wrap">
  <h1>挑戦モード – 激ムズランナー</h1>
  <div class="panel">
    <div class="row between">
      <div class="row">
        <span class="pill">15秒生存で #65 解放</span>
        <span>タイム：<span id="time">0.0</span>s</span>
        <span>ベスト：<span id="best">0.0</span>s</span>
      </div>
      <div class="row">
        <button class="btn" id="startBtn">START</button>
      </div>
    </div>

    <div class="board">
      <canvas id="cv"></canvas>
      <div class="overlay show" id="overlay">
        <div class="sheet">
          <h2>操作</h2>
          <p>ジャンプ：<b>クリック/タップ</b> または <b>Space / ↑</b>　　スライディング：<b>↓ / Shift</b></p>
          <p class="muted">速度は上がり続け、障害も容赦なし。15秒耐えれば解放！</p>
          <p id="status" class="result"></p>
        </div>
      </div>
    </div>

    <div class="row between" style="margin-top:10px">
      <div class="muted">※フォーカスが外れると自動一時停止</div>
      <a href="../dex/index.html" class="muted">← 図鑑へ戻る</a>
    </div>
  </div>
</div>

<script>
/* ========== DEX 連携（#65 解放） ========== */
const DEX_KEY = 'dex_state_v1';
const SECRET65_ID = 64;                 // #65（0始まりのID）
const SECRET_FILENAME = 'secret_65.png';
const UNLOCK_FLAG = 'secret65_unlocked';

function loadDex(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY)||'{}'); }catch{ return {}; } }
function saveDex(v){ localStorage.setItem(DEX_KEY, JSON.stringify(v||{})); }

function grantSecret65(){
  if (localStorage.getItem(UNLOCK_FLAG)) return;
  const dex = loadDex();
  dex.unlocked = Object.assign({}, dex.unlocked, { [SECRET65_ID]: true });
  dex.secret65 = SECRET_FILENAME;
  if (!dex.selected) dex.selected = SECRET_FILENAME;
  saveDex(dex);
  localStorage.setItem(UNLOCK_FLAG, '1');
  try {
    // 他タブに変更通知（対応環境のみ）
    window.dispatchEvent(new StorageEvent('storage', {key: DEX_KEY, newValue: JSON.stringify(dex)}));
  } catch(_) {}
}

/* ========== 激ムズランナー本体 ========== */
const TARGET_SEC = 15.0;                 // 生存目標（激ムズ）
const BASE_SPEED = 360;                  // 初速 px/s（速い）
const ACCEL      = 18;                   // 毎秒加速 px/s^2
const GRAVITY    = 2600;                 // 重力 px/s^2
const JUMP_V0    = 900;                  // 初速ジャンプ
const SLIDE_TIME = 0.42;                 // スライド秒
const COYOTE     = 0.06;                 // コヨーテタイム（着地直後の猶予）
const BUFFER     = 0.08;                 // 入力バッファ

// 画面・地形
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const overlay = document.getElementById('overlay');
const statusEl = document.getElementById('status');
const startBtn = document.getElementById('startBtn');
const timeEl = document.getElementById('time');
const bestEl = document.getElementById('best');

let best = +(localStorage.getItem('secret_runner_best')||0);
bestEl.textContent = best.toFixed(1);

// DPR対応＆自動サイズ
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const cssW = cv.clientWidth;
  const cssH = cv.clientHeight;
  cv.width  = Math.round(cssW * dpr);
  cv.height = Math.round(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

// プレイヤ
const player = {
  x: 120, y: 0, w: 28, h: 36,
  vx: 0, vy: 0,
  onGround: false,
  slideUntil: 0,
  lastGroundTime: 0,
  lastJumpPress: -1
};

// 障害物
/** type: 'spike'|'bar'|'drone' */
let hazards = [];
function spawnSpike(x){
  hazards.push({type:'spike', x, y: groundY()-18, w:22, h:22});
}
function spawnBar(x){
  // しゃがみで回避する低いバー
  hazards.push({type:'bar', x, y: groundY()-44, w:30, h:18});
}
function spawnDrone(x){
  // 中空ドローン（低め）…ジャンプで飛び越す or タイミング
  const h = groundY()-72;
  hazards.push({type:'drone', x, y: h, w:26, h:18, phase: Math.random()*Math.PI*2});
}

// ステージ
function groundY(){ return cv.clientHeight - 28; } // 地面ライン（CSSサイズ基準）

// ゲーム状態
let running=false, tStart=0, tPrev=0, raf=0, elapsed=0, speed=BASE_SPEED, spawnT=0, paused=false;

// リセット
function resetGame(){
  cancelAnimationFrame(raf);
  running=false; paused=false;
  timeEl.textContent = '0.0';
  statusEl.textContent = '';
  hazards.length = 0;
  elapsed = 0; speed = BASE_SPEED; spawnT = 0;
  player.x = 120; player.y = groundY()-player.h;
  player.vx = 0; player.vy = 0; player.onGround=true;
  player.slideUntil = 0;
  drawScene(0);
}
resetGame();

// 開始
startBtn.addEventListener('click', ()=>{
  overlay.classList.remove('show');
  resetGame();
  running=true;
  tStart = performance.now();
  tPrev  = tStart;
  raf = requestAnimationFrame(loop);
});

// 入力
function wantJump(){
  player.lastJumpPress = elapsed;
}
function wantSlide(){
  if (elapsed < player.slideUntil) return;
  player.slideUntil = elapsed + SLIDE_TIME;
}
cv.addEventListener('pointerdown', wantJump);
window.addEventListener('keydown', (e)=>{
  if (e.key === ' ' || e.key === 'ArrowUp'){ e.preventDefault(); wantJump(); }
  if (e.key === 'ArrowDown' || e.key === 'Shift'){ e.preventDefault(); wantSlide(); }
});

// 一時停止
document.addEventListener('visibilitychange', ()=>{
  if (document.hidden && running){
    paused = true;
    overlay.classList.add('show');
    statusEl.textContent = '一時停止中…';
  }else if (running && paused){
    paused = false;
    statusEl.textContent = '';
    overlay.classList.remove('show');
    tPrev = performance.now();
    raf = requestAnimationFrame(loop);
  }
});

// メインループ
function loop(ts){
  if (!running) return;
  const dt = Math.min(0.033, (ts - tPrev)/1000);
  tPrev = ts;
  elapsed += dt;

  // 難易度スケーリング
  speed = BASE_SPEED + ACCEL * elapsed; // 加速し続ける

  // 物理
  const gndY = groundY();
  const sliding = elapsed < player.slideUntil;
  const ph = sliding ? 22 : 36; // 高さ
  // コヨーテタイム判定
  if (player.onGround) player.lastGroundTime = elapsed;

  // ジャンプ入力（バッファ＋コヨーテ）
  const canCoyote = (elapsed - player.lastGroundTime) <= COYOTE;
  const buffered  = (elapsed - player.lastJumpPress) <= BUFFER;
  if (buffered && (player.onGround || canCoyote)){
    player.vy = -JUMP_V0;
    player.onGround = false;
    player.lastJumpPress = -1;
  }

  // 重力
  player.vy += GRAVITY * dt;
  player.y  += player.vy * dt;

  // 着地
  if (player.y + ph >= gndY){
    player.y = gndY - ph;
    player.vy = 0;
    player.onGround = true;
  }else{
    player.onGround = false;
  }

  // スポーン（時間依存で間隔が詰まる）
  spawnT -= dt;
  const minInt = 0.22, maxInt = 0.55;
  const interval = Math.max(minInt, maxInt - elapsed*0.02);
  if (spawnT <= 0){
    spawnPattern();
    spawnT = interval;
  }

  // 障害物移動
  hazards.forEach(o=>{
    o.x -= speed * dt;
    if (o.type === 'drone'){
      // ふわふわ垂直揺れ（狭い隙間を作る）
      o.y += Math.sin((elapsed + o.phase)*8) * 0.7;
    }
  });
  hazards = hazards.filter(o=> o.x + o.w > -40); // 画面外の掃除

  // 衝突
  const pw = 26, pr = {x:player.x-pw/2, y:player.y, w:pw, h:ph};
  for (const o of hazards){
    if (rectHit(pr, o)){
      fail();
      return;
    }
  }

  // クリア判定
  timeEl.textContent = elapsed.toFixed(1);
  if (elapsed >= TARGET_SEC){
    clear();
    return;
  }

  // 描画
  drawScene(ph);

  raf = requestAnimationFrame(loop);
}

// ぶつかった
function fail(){
  running=false;
  if (elapsed > best){ best = elapsed; localStorage.setItem('secret_runner_best', best); bestEl.textContent = best.toFixed(1); }
  overlay.classList.add('show');
  statusEl.innerHTML = `<span class="bad">失敗… ${elapsed.toFixed(1)}s 生存</span>`;
}

// クリア
function clear(){
  running=false;
  if (elapsed > best){ best = elapsed; localStorage.setItem('secret_runner_best', best); bestEl.textContent = best.toFixed(1); }
  grantSecret65();
  overlay.classList.add('show');
  statusEl.innerHTML = `<span class="good">解放！ ${elapsed.toFixed(1)}s 生存 → 図鑑で #65 が使えるよ</span>`;
  setTimeout(()=> location.href = '../dex/index.html', 900);
}

// 当たり判定
function rectHit(a,b){
  return !(a.x+a.w < b.x || b.x+b.w < a.x || a.y+a.h < b.y || b.y+b.h < a.y);
}

// パターン生成（理不尽寄り）
function spawnPattern(){
  const x0 = cv.clientWidth + 40;
  const r = Math.random();
  if (elapsed < 4){
    // 序盤：単体 or 2連
    if (r < 0.5) spawnSpike(x0);
    else if (r < 0.8){ spawnSpike(x0); spawnSpike(x0+70); }
    else spawnDrone(x0+20);
  }else if (elapsed < 10){
    // 中盤：混合
    if (r < 0.33){ spawnSpike(x0); spawnDrone(x0+90); }
    else if (r < 0.66){ spawnBar(x0); spawnSpike(x0+80); }
    else { spawnDrone(x0); spawnDrone(x0+80); }
  }else{
    // 終盤：えげつない
    const choice = Math.floor(Math.random()*4);
    switch(choice){
      case 0: // スパイク3連
        spawnSpike(x0); spawnSpike(x0+65); spawnSpike(x0+130); break;
      case 1: // 低バー→ドローン→スパイク
        spawnBar(x0); spawnDrone(x0+80); spawnSpike(x0+160); break;
      case 2: // ドローン3連（上下微揺れ）
        spawnDrone(x0); spawnDrone(x0+70); spawnDrone(x0+140); break;
      default:// バー2連＋スパイク
        spawnBar(x0); spawnBar(x0+90); spawnSpike(x0+170); break;
    }
  }
}

// 描画
function drawScene(ph){
  // 背景クリア
  ctx.clearRect(0,0,cv.clientWidth,cv.clientHeight);

  // グリッド流し（前進感）
  const t = elapsed*120;
  ctx.save();
  ctx.globalAlpha = 0.3;
  ctx.strokeStyle = '#14314d';
  ctx.lineWidth = 1;
  const step = 40;
  const off = (t % step);
  for (let y = -off; y < cv.clientHeight; y += step){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.clientWidth,y); ctx.stroke();
  }
  for (let x = -(off*0.6); x < cv.clientWidth; x += step){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.clientHeight); ctx.stroke();
  }
  ctx.restore();

  // 地面
  ctx.fillStyle = '#0e243a';
  ctx.fillRect(0, groundY(), cv.clientWidth, 28);

  // プレイヤ（スライド時は低く）
  ctx.fillStyle = '#22d3ee';
  const pw = 26;
  ctx.fillRect(player.x - pw/2, player.y, pw, ph);

  // 障害
  hazards.forEach(o=>{
    if (o.type==='spike'){
      ctx.fillStyle = '#ef4444';
      // 三角ぽく描く（当たりは矩形）
      ctx.beginPath();
      ctx.moveTo(o.x, o.y+o.h);
      ctx.lineTo(o.x+o.w/2, o.y);
      ctx.lineTo(o.x+o.w, o.y+o.h);
      ctx.closePath();
      ctx.fill();
    }else if (o.type==='bar'){
      ctx.fillStyle = '#f59e0b';
      ctx.fillRect(o.x, o.y, o.w, o.h);
    }else{
      ctx.fillStyle = '#84cc16';
      ctx.fillRect(o.x, o.y, o.w, o.h);
      // プロペラ風
      ctx.fillRect(o.x-6, o.y+o.h/2-2, o.w+12, 4);
    }
  });

  // タイム
  ctx.fillStyle = '#9ca3af';
  ctx.font = '12px system-ui';
  ctx.fillText('激ムズ', 10, 16);
}

</script>
</body>
</html>
