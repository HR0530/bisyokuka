<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>シークレット挑戦 #69：量子床（激むず・改）</title>
  <!-- 図鑑連携ヘルパ（unlockSecret(no, filename) を提供） -->
  <script src="../_unlock.js"></script>
  <style>
    :root{
      --bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;
      --accent:#f59e0b;--ok:#22c55e;--warn:#ef4444;--muted:#9ca3af
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:960px;margin:24px auto;padding:16px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
    .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .left{display:flex;gap:10px;align-items:center}
    .btn{background:var(--accent);color:#221a05;border:none;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
    .btn.ghost{background:#0ea5e9;color:#031423;text-decoration:none;display:inline-block}
    .btn.reset{background:#ef4444;color:#fff}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .muted{color:var(--muted);text-decoration:none}
    .stats{display:flex;gap:16px;align-items:center}
    .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
    canvas{
      display:block;width:100%;
      height:clamp(380px, calc(100svh - 260px), 720px);
      margin-top:10px;border-radius:12px;border:1px solid #1a2740;
      background:linear-gradient(#0f2238,#0b1626)
    }
    .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45);z-index:2}
    .overlay .sheet{background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;display:grid;gap:10px;justify-items:center}
  </style>
</head>
<body>
<div class="wrap">
  <h1>シークレット挑戦 #69：量子床（激むず・改）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">勝利条件：5エリア連続突破（制限 80s）</span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span>エリア：<b id="area">1</b>/5</span>
      </div>
      <div class="left">
        <button class="btn" id="startBtn">START</button>
        <a class="btn ghost" id="backBtn" href="#">図鑑へ戻る</a>
        <button class="btn reset" id="resetUnlockBtn">解放リセット（#69）</button>
      </div>
    </div>

    <canvas id="cv"></canvas>

    <!-- 成否オーバーレイ -->
    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" id="backBtn2" href="#">図鑑へ戻る</a>
        </div>
      </div>
    </div>
  </div>
  <div class="muted" style="margin-top:8px;line-height:1.6">
    操作：←→ 移動 ・ <b>SPACE</b> ジャンプ（コヨーテ 80ms）。<br/>
    タイルは踏むまで未観測。踏んだ瞬間に安全/崩壊が確率で決定（中心着地・水平進入ほど安全／高速落下は危険）。崩壊は0.35s遅延。<br/>
    追加障害物：<b>点滅レーザー</b>（赤バー）はON/OFFを繰り返す。OFF中は通過可（＝必ず抜け道あり）。
  </div>
</div>

<script>
/* ====== パス解決（図鑑へ戻る） ====== */
function resolveDexPath(){
  const p = location.pathname;
  if (p.includes('/pages/characters/secret/')) return '../../dex/index.html';
  if (p.includes('/pages/characters/'))        return '../dex/index.html';
  if (p.includes('/pages/'))                   return 'characters/dex/index.html';
  return 'pages/characters/dex/index.html';
}
document.getElementById('backBtn').href  = resolveDexPath();
document.getElementById('backBtn2').href = resolveDexPath();

/* ====== スクロール抑止（矢印/スペース） ====== */
window.addEventListener('keydown', (e)=>{
  const k=e.code;
  if(k==='ArrowUp'||k==='ArrowDown'||k==='ArrowLeft'||k==='ArrowRight'||k==='Space'){ e.preventDefault(); }
},{passive:false});

/* ====== 図鑑連携：#69 解放/リセット ====== */
const SECRET_NO = 69;
const SECRET_FILE = 'secret_69.png';
const DEX_KEY='dex_state_v1';
const ID_0BASE = SECRET_NO - 1; // 68

function unlock69(){
  if (typeof unlockSecret === 'function'){ unlockSecret(SECRET_NO, SECRET_FILE); return; }
  const dex = JSON.parse(localStorage.getItem(DEX_KEY)||'{}');
  dex.unlocked = Object.assign({}, dex.unlocked, {[ID_0BASE]:true});
  dex.secretFiles = Object.assign({}, dex.secretFiles, {[String(ID_0BASE)]:SECRET_FILE});
  if(!dex.selected) dex.selected = SECRET_FILE;
  localStorage.setItem(DEX_KEY, JSON.stringify(dex));
  try{ window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)})); }catch(_){}
}

document.getElementById('resetUnlockBtn').addEventListener('click', ()=>{
  const ok = confirm('#69 の解放状態をリセットし、再びロックします。よろしいですか？');
  if(!ok) return;
  const dex = JSON.parse(localStorage.getItem(DEX_KEY)||'{}');
  if (dex.unlocked) delete dex.unlocked[ID_0BASE];
  if (dex.secretFiles) delete dex.secretFiles[String(ID_0BASE)];
  if (dex.selected === SECRET_FILE) dex.selected = 'char.png';
  localStorage.setItem(DEX_KEY, JSON.stringify(dex));
  try{ window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)})); }catch(_){}
  alert('#69 の解放をリセットしました。');
});

/* ====== Canvas & DPI ====== */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', ()=>{ fitCanvas(); layoutArea(currentArea); drawScene(0); }, {passive:true});
fitCanvas();

/* ====== UI ====== */
const startBtn = document.getElementById('startBtn');
const retryBtn = document.getElementById('retryBtn');
const timeEl   = document.getElementById('time');
const areaEl   = document.getElementById('area');
const ov       = document.getElementById('ov');
const ovMsg    = document.getElementById('ovMsg');
const ovSub    = document.getElementById('ovSub');

/* ====== 物理・ゲーム定数（やや易化してクリア保証） ====== */
let playing=false, raf=0, t0=0, last=0, paused=false;
const TIME_LIMIT = 80;
const G = 1650;
const MOVE = 330;
const JUMP_V = -540;
const COYOTE = 0.08;
const FRICTION = 0.9;
// 量子床パラメータ（少し安全寄り）
const SAFE_BASE = 0.58;            // ↑
const BONUS_CENTER_MAX = 0.10;
const BONUS_ANGLE_MAX  = 0.08;
const PENALTY_SPEED_MAX= 0.18;     // ↓
const VY_REF = 760;
const TILE_BREAK_DELAY = 0.35;
// エリア構成
const AREAS_TOTAL = 5;
let currentArea = 1;

// プレイヤー
let px=0, py=0, vx=0, vy=0, onGround=false, coyote=0;
let timer=0;
let platforms=[], tiles=[], lasers=[], goal=null, startPad=null;

/* ====== 入力 ====== */
const keys = {left:false, right:false, jump:false};
window.addEventListener('keydown', (e)=>{ if(e.repeat) return;
  if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = true;
  if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right= true;
  if (e.code==='Space'    ) keys.jump = true;
});
window.addEventListener('keyup', (e)=>{
  if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = false;
  if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right= false;
  if (e.code==='Space'    ) keys.jump = false;
});

/* ====== レイアウト ====== */
function unit(){ return Math.max(18, Math.min(42, cv.clientHeight/24)); }
function layoutArea(area){
  platforms=[]; tiles=[]; lasers=[];
  const U = unit();
  const groundY = cv.clientHeight - U*2;
  const startW = U*4;
  const tileW  = U*2.1, tileH = U*0.7, gapX = U*0.95;

  // スタート台
  startPad = {x: U*1.0, y: groundY, w: startW, h: U*0.8, type:'start'};
  platforms.push(startPad);

  // タイル列
  const cols = 10 + area*2; // 12..20
  let baseX = startPad.x + startPad.w + U*1.0;
  for (let i=0;i<cols;i++){
    const lane = (i%2===0)? 0 : 1;
    const tx = baseX + i*(tileW + gapX);
    const ty = groundY - U*(2.6 + lane*1.25 + Math.random()*0.7);
    tiles.push({x:tx,y:ty,w:tileW,h:tileH,observed:false,safe:null,breakAt:0,state:'unknown',shake:0});
  }

  // ゴール台
  const lastTile = tiles[tiles.length-1];
  goal = {x: lastTile.x + tileW + U*1.4, y: groundY - U*3.0, w: U*3.2, h: U*1.0, type:'goal'};
  platforms.push(goal);

  // 点滅レーザー（ON/OFF。OFF中は必ず通れる）
  const laserCount = 1 + Math.floor(area/2); // 1,1,2,2,3
  for (let i=0;i<laserCount;i++){
    const spanX1 = startPad.x + startPad.w + U*(2+i*3);
    const spanX2 = goal.x - U*(2+i*2);
    const y = 0;
    const w = 6; // 細め
    const speed = 90 + area*20 + Math.random()*30;
    const phase = Math.random();
    const period = 1.2 + Math.random()*0.4;  // 1.2〜1.6s
    const onTime = 0.7;                       // ON 0.7s / OFF 残り → 必ず隙間あり
    lasers.push({
      x: spanX1 + (spanX2-spanX1)*phase, y, w, h: cv.clientHeight,
      minX: spanX1, maxX: spanX2, spd: (Math.random()<0.5?-1:1)*speed,
      period, onTime, phase: Math.random()*period
    });
  }

  // プレイヤー初期位置
  px = startPad.x + startPad.w*0.5 - U*0.5;
  py = startPad.y - U*2.1;
  vx = 0; vy = 0; onGround=true; coyote=0;
}

/* ====== タイル観測 ====== */
function observeTile(t){
  if (t.observed) return;
  const speed = Math.sqrt(vx*vx + vy*vy);
  const horizRatio = Math.abs(vx) / (speed + 1e-6);
  const centerDx = Math.abs((px + PW()/2) - (t.x + t.w/2));
  const centerRate = 1 - Math.min(1, centerDx / (t.w/2));
  let pSafe = SAFE_BASE + centerRate*BONUS_CENTER_MAX + horizRatio*BONUS_ANGLE_MAX - Math.min(1, Math.abs(vy)/VY_REF)*PENALTY_SPEED_MAX;
  pSafe = Math.max(0.20, Math.min(0.86, pSafe)); // やや甘め
  t.observed = true;
  const decoyChance = 0.03 + (currentArea-1)*0.015; // 3%→9%
  if (Math.random() < decoyChance){ t.safe=false; t.state='broken'; return; }
  t.safe = Math.random() < pSafe;
  if (!t.safe){ t.state='crack'; t.breakAt=timer+TILE_BREAK_DELAY; t.shake=1; } else { t.state='solid'; }
}

/* ====== 衝突ヘルパ ====== */
function rectsOverlap(a,b){ return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h); }
function PR(){ return {x:px, y:py, w:PW(), h:PH()}; }
function PW(){ return unit()*1.2; }
function PH(){ return unit()*1.8; }

/* ====== 成否 ====== */
function fail(msg){ playing=false; ovMsg.textContent='失敗…'; ovSub.textContent=msg||'もう一度挑戦しよう'; ov.style.display='grid'; }
function success(){ playing=false; unlock69(); ovMsg.textContent='解放成功！ #69 が使えるようになった'; ovSub.textContent='図鑑で選択できます。'; ov.style.display='grid'; }

/* ====== 進行 ====== */
function nextArea(){ currentArea++; if (currentArea>AREAS_TOTAL){ success(); return; } areaEl.textContent=currentArea; layoutArea(currentArea); }

/* ====== ループ ====== */
function loop(ts){
  if (!playing) return;
  if (!last) last = ts;
  const dt = (ts - last)/1000; last = ts;
  timer = (ts - t0)/1000; timeEl.textContent = timer.toFixed(1);
  if (timer > TIME_LIMIT){ fail('時間切れ…'); return; }

  // 入力
  if (keys.left)  vx = -MOVE;
  if (keys.right) vx =  MOVE;
  if (!keys.left && !keys.right) vx *= FRICTION;

  // ジャンプ（コヨーテ）
  if (keys.jump && (onGround || coyote>0)){ vy=JUMP_V; onGround=false; coyote=0; keys.jump=false; }

  // 重力
  vy += G*dt;

  // 位置更新
  px += vx*dt; py += vy*dt;

  // 画面外
  if (py > cv.clientHeight + unit()*4 || px < -unit()*2 || px > cv.clientWidth + unit()*2){ fail('奈落に落ちた…'); return; }

  // 接地：スタート/ゴール
  const player = PR(); onGround=false;
  for(const p of [startPad, goal]){
    if (!p) continue;
    const prevBottom = player.y + player.h - vy*dt;
    if (player.x + player.w > p.x && player.x < p.x+p.w){
      if (prevBottom <= p.y && player.y + player.h >= p.y){ py = p.y - player.h; vy=0; onGround=true; coyote=COYOTE; }
    }
  }

  // タイル
  for (const t of tiles){
    if (t.state==='broken') continue;
    if (t.state==='crack' && timer>=t.breakAt){ t.state='broken'; continue; }
    const prevBottom = player.y + player.h - vy*dt;
    if (player.x + player.w > t.x && player.x < t.x + t.w){
      if (prevBottom <= t.y && player.y + player.h >= t.y){
        observeTile(t);
        if (t.state!=='broken'){ py = t.y - player.h; vy=0; onGround=true; coyote=COYOTE; }
      }
    }
  }

  // レーザー（点滅）
  for (const L of lasers){
    L.x += L.spd*dt;
    if (L.x < L.minX){ L.x = L.minX; L.spd *= -1; }
    if (L.x > L.maxX){ L.x = L.maxX; L.spd *= -1; }
    L.phase = (L.phase + dt) % L.period;
    const active = L.phase < L.onTime; // ON中のみ当たり判定
    if (active){
      const laserRect = {x:L.x - L.w/2, y:0, w:L.w, h:cv.clientHeight};
      if (rectsOverlap(PR(), laserRect)){ fail('レーザーに触れた…'); return; }
    }
  }

  // ゴール到達
  if (rectsOverlap(PR(), goal)){ nextArea(); }

  drawScene(dt);
  raf = requestAnimationFrame(loop);
}

/* ====== 描画 ====== */
function drawScene(dt){
  const w = cv.clientWidth, h=cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0, '#0f2238'); grad.addColorStop(1, '#0b1626');
  ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

  // グリッド
  ctx.strokeStyle = 'rgba(255,255,255,.06)'; ctx.lineWidth=1;
  for(let y=0;y<h;y+=unit()*2){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

  // 台
  [startPad, goal].forEach(p=>{ if(!p) return; ctx.fillStyle=(p===goal)?'#10b981':'#334155'; ctx.fillRect(p.x,p.y,p.w,p.h); });

  // タイル
  tiles.forEach(t=>{
    let ox=0; if(t.shake>0){ ox=(Math.random()*2-1)*2; t.shake=Math.max(0,t.shake-dt*3); }
    if (t.state==='unknown') ctx.fillStyle='#475569';
    else if(t.state==='solid') ctx.fillStyle='#64748b';
    else if(t.state==='crack') ctx.fillStyle='#ef4444';
    else ctx.fillStyle='rgba(239,68,68,.15)';
    ctx.fillRect(t.x+ox,t.y,t.w,t.h);
    if (t.state==='crack'){ ctx.strokeStyle='#fde68a'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(t.x+4+ox,t.y+2); ctx.lineTo(t.x+t.w-4+ox,t.y+t.h-2); ctx.stroke(); }
  });

  // レーザー（点滅表現：ON=赤強、OFF=薄い）
  lasers.forEach(L=>{
    const active = L.phase < L.onTime;
    const x0 = L.x - L.w/2;
    const g = ctx.createLinearGradient(x0,0,x0+L.w,0);
    const a = active ? 0.95 : 0.15;
    g.addColorStop(0,`rgba(239,68,68,0)`);
    g.addColorStop(0.5,`rgba(239,68,68,${a})`);
    g.addColorStop(1,`rgba(239,68,68,0)`);
    ctx.fillStyle = g; ctx.fillRect(x0,0,L.w,h);
  });

  // プレイヤー
  ctx.fillStyle = '#22d3ee'; ctx.fillRect(px, py, PW(), PH());
}

/* ====== 開始/再試行/初期化 ====== */
function resetAll(){
  playing=false; cancelAnimationFrame(raf);
  timer = 0; timeEl.textContent='0.0';
  currentArea = 1; areaEl.textContent = currentArea;
  ov.style.display='none';
  layoutArea(currentArea);
  drawScene(0);
}
function start(){
  resetAll();
  playing=true;
  t0 = performance.now(); last = t0; paused=false;
  raf = requestAnimationFrame(loop);
}
startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);
document.addEventListener('visibilitychange', ()=>{ paused = document.hidden; });

/* 起動 */
resetAll();
</script>
</body>
</html>
