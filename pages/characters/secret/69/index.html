<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>シークレット挑戦 #69：量子床（激むず）</title>
  <!-- 図鑑連携ヘルパー（unlockSecret(no, filename) を提供） -->
  <script src="../_unlock.js"></script>
  <style>
    :root{
      --bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;
      --accent:#f59e0b;--ok:#22c55e;--warn:#ef4444;--muted:#9ca3af
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:960px;margin:24px auto;padding:16px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
    .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .btn{
      background:var(--accent);color:#221a05;border:none;border-radius:10px;
      padding:10px 14px;font-weight:800;cursor:pointer
    }
    .btn.ghost{background:#0ea5e9;color:#031423}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .muted{color:var(--muted);text-decoration:none}
    .stats{display:flex;gap:16px;align-items:center}
    .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
    canvas{
      display:block;width:100%;
      height:clamp(360px, calc(100svh - 260px), 700px);
      margin-top:10px;border-radius:12px;border:1px solid #1a2740;
      background:linear-gradient(#0f2238,#0b1626)
    }
    .overlay{
      position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45);z-index:2
    }
    .overlay .sheet{
      background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;
      display:grid;gap:10px;justify-items:center
    }
    /* スタート/戻るを少し左寄せ */
    .row .left{display:flex;gap:10px;align-items:center}
  </style>
</head>
<body>
<div class="wrap">
  <h1>シークレット挑戦 #69：量子床（激むず）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">勝利条件：3エリア連続突破（制限 60s）</span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span>エリア：<b id="area">1</b>/3</span>
      </div>
      <div class="left">
        <button class="btn" id="startBtn">START</button>
        <a class="muted" href="../dex/index.html">← 図鑑へ戻る</a>
      </div>
    </div>
    <canvas id="cv"></canvas>

    <!-- 失敗・成功オーバーレイ -->
    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../dex/index.html">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>
  <div class="muted" style="margin-top:8px;line-height:1.6">
    操作：←→ 移動 ・ <b>SPACE</b> ジャンプ（コヨーテ 80ms）。<br/>
    タイルは踏むまで「未観測」。踏んだ瞬間に安全/崩壊が“確率”で決定（着地の速さ・角度・中心からのズレで変動）。崩壊タイルは0.35sで落下。
  </div>
</div>

<script>
/* ======= アンロック（#69） ======= */
const SECRET_NO = 69;
const SECRET_FILE = 'secret_69.png';
function unlock69(){
  try{
    if (typeof unlockSecret === 'function'){
      unlockSecret(SECRET_NO, SECRET_FILE);
    }else{
      // フォールバック（_unlock.jsが無い場合）
      const DEX_KEY='dex_state_v1';
      const id = 68; // 0始まり：#69
      const dex = JSON.parse(localStorage.getItem(DEX_KEY)||'{}');
      dex.unlocked = Object.assign({}, dex.unlocked, {[id]:true});
      dex.secretFiles = Object.assign({}, dex.secretFiles, {[String(id)]:SECRET_FILE});
      if(!dex.selected) dex.selected = SECRET_FILE;
      localStorage.setItem(DEX_KEY, JSON.stringify(dex));
      try{ window.dispatchEvent(new StorageEvent('storage', {key:DEX_KEY,newValue:JSON.stringify(dex)})); }catch(_){}
    }
  }catch(e){ console.warn('unlock failed', e); }
}

/* ======= スクロール抑止（Arrow/Space） ======= */
window.addEventListener('keydown', (e)=>{
  const k = e.code;
  if (k==='ArrowUp' || k==='ArrowDown' || k==='ArrowLeft' || k==='ArrowRight' || k==='Space'){
    e.preventDefault();
  }
}, {passive:false});

/* ======= Canvas & DPI ======= */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', ()=>{ fitCanvas(); layoutArea(currentArea); drawScene(0); }, {passive:true});
fitCanvas();

/* ======= UI ======= */
const startBtn = document.getElementById('startBtn');
const timeEl   = document.getElementById('time');
const areaEl   = document.getElementById('area');
const ov       = document.getElementById('ov');
const ovMsg    = document.getElementById('ovMsg');
const ovSub    = document.getElementById('ovSub');
const retryBtn = document.getElementById('retryBtn');

/* ======= 物理・ゲーム定数（調整済み“激むず”） ======= */
let playing=false, raf=0, t0=0, last=0, paused=false;
const TIME_LIMIT = 60;
const G = 1600;                    // 重力 px/s^2
const MOVE = 320;                  // 横移動 px/s
const JUMP_V = -530;               // ジャンプ初速
const COYOTE = 0.08;               // コヨーテ猶予
const FRICTION = 0.9;              // 接地時の横減衰
// 量子床パラメータ
const SAFE_BASE = 0.58;            // 基本安全率
const BONUS_CENTER_MAX = 0.12;     // 中心着地ボーナス
const BONUS_ANGLE_MAX  = 0.10;     // 水平寄り進入ボーナス
const PENALTY_SPEED_MAX= 0.18;     // 落下速度ペナルティ
const VY_REF = 750;                // 正規化用
const TILE_BREAK_DELAY = 0.35;     // 崩壊までの遅延
// エリア構成
const AREAS_TOTAL = 3;
let currentArea = 1;

let px=0, py=0, vx=0, vy=0, onGround=false, coyote=0;
let timer=0;
let platforms=[], tiles=[], goal=null, startPad=null;

/* ======= 入力 ======= */
const keys = {left:false, right:false, jump:false};
window.addEventListener('keydown', (e)=>{
  if (e.repeat) return;
  if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = true;
  if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right= true;
  if (e.code==='Space'    ) keys.jump = true;
});
window.addEventListener('keyup', (e)=>{
  if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = false;
  if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right= false;
  if (e.code==='Space'    ) keys.jump = false;
});

/* ======= レイアウト ======= */
function unit(){ return Math.max(18, Math.min(40, cv.clientHeight/24)); } // 基準長さ
function layoutArea(area){
  platforms=[]; tiles=[];
  const U = unit();
  const groundY = cv.clientHeight - U*2;
  const startW = U*4;
  const tileW  = U*2.2, tileH = U*0.7, gapX = U*1.0;

  // スタート台
  startPad = {x: U*1.0, y: groundY, w: startW, h: U*0.8, type:'start'};
  platforms.push(startPad);

  // タイル列を 2 レーンでジグザグ配置（高さランダム）
  const cols = 9; // 各エリアのタイル数
  let baseX = startPad.x + startPad.w + U*1.0;
  for (let i=0;i<cols;i++){
    const lane = (i%2===0)? 0 : 1;
    const tx = baseX + i*(tileW + gapX);
    const ty = groundY - U*(2.4 + lane*1.2 + Math.random()*0.5); // 少し高さばらつき
    tiles.push({
      x: tx, y: ty, w: tileW, h: tileH,
      observed:false, safe:null, breakAt:0, state:'unknown', shake:0
    });
  }

  // ゴール台
  const lastTile = tiles[tiles.length-1];
  goal = {x: lastTile.x + tileW + U*1.2, y: groundY - U*2.8, w: U*3.2, h: U*1.0, type:'goal'};
  platforms.push(goal);

  // プレイヤー初期位置
  px = startPad.x + startPad.w*0.5 - U*0.5;
  py = startPad.y - U*2.1;
  vx = 0; vy = 0; onGround=true; coyote=0;
}

/* ======= タイル観測（確率の偏り） ======= */
function observeTile(t){
  if (t.observed) return;
  // 直前の着地ベクトルを使用
  const speed = Math.sqrt(vx*vx + vy*vy);
  const horizRatio = Math.abs(vx) / (speed + 1e-6); // 0..1（水平寄りが1）
  const centerDx = Math.abs((px + PW()/2) - (t.x + t.w/2));
  const centerRate = 1 - Math.min(1, centerDx / (t.w/2)); // 0..1（中心ほど1）

  let pSafe = SAFE_BASE
            + centerRate * BONUS_CENTER_MAX
            + horizRatio * BONUS_ANGLE_MAX
            - Math.min(1, Math.abs(vy)/VY_REF) * PENALTY_SPEED_MAX;

  pSafe = Math.max(0.2, Math.min(0.86, pSafe)); // 下限/上限

  t.observed = true;
  t.safe = Math.random() < pSafe;
  if (!t.safe){
    t.state = 'crack';
    t.breakAt = timer + TILE_BREAK_DELAY;
    t.shake = 1; // 少し揺らす
  }else{
    t.state = 'solid';
  }
}

/* ======= 衝突ヘルパ ======= */
function rectsOverlap(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}
function PR(){ return {x:px, y:py, w:PW(), h:PH()}; }
function PW(){ return unit()*1.2; }
function PH(){ return unit()*1.8; }

/* ======= 失敗・成功 ======= */
function fail(msg){
  playing=false;
  ovMsg.textContent = '失敗…';
  ovSub.textContent = msg || 'もう一度挑戦しよう';
  ov.style.display = 'grid';
}
function success(){
  playing=false;
  unlock69();
  ovMsg.textContent = '解放成功！ #69 が使えるようになった';
  ovSub.textContent = '図鑑で選択できます。';
  ov.style.display = 'grid';
}

/* ======= 進行 ======= */
function nextArea(){
  currentArea++;
  if (currentArea > AREAS_TOTAL){
    success(); return;
  }
  areaEl.textContent = currentArea;
  layoutArea(currentArea);
}

/* ======= ループ ======= */
function loop(ts){
  if (!playing) return;
  if (!last) last = ts;
  let dt = (ts - last)/1000; last = ts;
  timer = (ts - t0)/1000;
  timeEl.textContent = timer.toFixed(1);
  if (timer > TIME_LIMIT){ fail('時間切れ…'); return;}

  // 入力
  if (keys.left)  vx = -MOVE;
  if (keys.right) vx =  MOVE;
  if (!keys.left && !keys.right) vx *= FRICTION;

  // ジャンプ（コヨーテ）
  if (keys.jump){
    if (onGround || coyote > 0){
      vy = JUMP_V; onGround=false; coyote = 0; keys.jump = false;
    }
  }

  // 重力
  vy += G*dt;

  // 位置更新
  px += vx*dt;
  py += vy*dt;

  // 画面外 = 失敗
  if (py > cv.clientHeight + unit()*4 || px < -unit()*2 || px > cv.clientWidth + unit()*2){
    fail('奈落に落ちた…'); return;
  }

  // 接地処理（上からのみ）
  const player = PR();
  onGround = false;

  // スタート＆ゴール台は通常の床
  for(const p of [startPad, goal]){
    if (!p) continue;
    const floor = {x:p.x, y:p.y, w:p.w, h:p.h};
    const prevBottom = player.y + player.h - vy*dt; // 前フレームの底
    if (player.x + player.w > floor.x && player.x < floor.x+floor.w){
      if (prevBottom <= floor.y && player.y + player.h >= floor.y){
        // 着地
        py = floor.y - player.h;
        vy = 0; onGround = true; coyote = COYOTE;
      }
    }
  }

  // タイル衝突＆観測
  for (const t of tiles){
    // 壊れた後は無視
    if (t.state === 'broken') continue;
    // 破断時刻を過ぎたら壊す
    if (t.state === 'crack' && timer >= t.breakAt){
      t.state = 'broken';
      continue;
    }
    // プレイヤー上面からの接地のみ判定
    const prevBottom = player.y + player.h - vy*dt;
    if (player.x + player.w > t.x && player.x < t.x + t.w){
      if (prevBottom <= t.y && player.y + player.h >= t.y){
        // 着地予定。観測して状態を確定
        observeTile(t);
        if (t.state === 'broken'){
          // 既に崩れていた（踏み抜き）
          // 何もしない→落下
        }else{
          // とりあえず乗る（crack でも遅延までは乗れる）
          py = t.y - player.h;
          vy = 0; onGround = true; coyote = COYOTE;
        }
      }
    }
  }

  // ゴール到達？
  if (rectsOverlap(PR(), goal)){
    nextArea(); // その場で次エリアに切替
  }

  // 描画
  drawScene(dt);
  raf = requestAnimationFrame(loop);
}

/* ======= 描画 ======= */
function drawScene(dt){
  const w = cv.clientWidth, h=cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景
  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0, '#0f2238'); grad.addColorStop(1, '#0b1626');
  ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

  // 装飾グリッド
  ctx.strokeStyle = 'rgba(255,255,255,.06)';
  ctx.lineWidth = 1;
  for(let y=0;y<h;y+=unit()*2){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

  // スタート・ゴール
  [startPad, goal].forEach(p=>{
    if(!p) return;
    ctx.fillStyle = (p===goal)? '#10b981':'#334155';
    ctx.fillRect(p.x, p.y, p.w, p.h);
  });

  // タイル
  tiles.forEach(t=>{
    // shake
    let ox = 0;
    if (t.shake>0){
      ox = (Math.random()*2-1)*2;
      t.shake = Math.max(0, t.shake - dt*3);
    }
    if (t.state==='unknown'){
      ctx.fillStyle = '#475569';
    }else if(t.state==='solid'){
      ctx.fillStyle = '#64748b';
    }else if(t.state==='crack'){
      ctx.fillStyle = '#ef4444';
    }else{
      // broken → 落下演出（薄く）
      ctx.fillStyle = 'rgba(239,68,68,.15)';
    }
    ctx.fillRect(t.x+ox, t.y, t.w, t.h);
    // 亀裂線
    if (t.state==='crack'){
      ctx.strokeStyle = '#fde68a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(t.x+4+ox, t.y+2);
      ctx.lineTo(t.x+t.w-4+ox, t.y+t.h-2);
      ctx.stroke();
    }
  });

  // プレイヤー
  ctx.fillStyle = '#22d3ee';
  ctx.fillRect(px, py, PW(), PH());
}

/* ======= 開始/再試行/初期化 ======= */
function resetAll(){
  playing=false; cancelAnimationFrame(raf);
  timer = 0; timeEl.textContent='0.0';
  currentArea = 1; areaEl.textContent = currentArea;
  ov.style.display='none';
  layoutArea(currentArea);
  drawScene(0);
}
function start(){
  resetAll();
  playing=true;
  t0 = performance.now(); last = t0; paused=false;
  raf = requestAnimationFrame(loop);
}
startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);
document.addEventListener('visibilitychange', ()=>{ paused = document.hidden; });

/* 起動 */
resetAll();
</script>
</body>
</html>
