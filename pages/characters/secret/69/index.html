<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>シークレット挑戦 #69：量子床（超激むず）</title>
  <!-- 図鑑連携ヘルパ（unlockSecret(no, filename) を提供） -->
  <script src="../_unlock.js"></script>
  <style>
    :root{
      --bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;
      --accent:#f59e0b;--ok:#22c55e;--warn:#ef4444;--muted:#9ca3af
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:960px;margin:24px auto;padding:16px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
    .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .left{display:flex;gap:10px;align-items:center}
    .btn{
      background:var(--accent);color:#221a05;border:none;border-radius:10px;
      padding:10px 14px;font-weight:800;cursor:pointer
    }
    .btn.ghost{background:#0ea5e9;color:#031423}
    .btn.reset{background:#ef4444;color:#fff}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .muted{color:var(--muted);text-decoration:none}
    .stats{display:flex;gap:16px;align-items:center}
    .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
    canvas{
      display:block;width:100%;
      height:clamp(380px, calc(100svh - 260px), 720px);
      margin-top:10px;border-radius:12px;border:1px solid #1a2740;
      background:linear-gradient(#0f2238,#0b1626)
    }
    .overlay{
      position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45);z-index:2
    }
    .overlay .sheet{
      background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;
      display:grid;gap:10px;justify-items:center
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1>シークレット挑戦 #69：量子床（超激むず）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">勝利条件：5エリア連続突破（制限 75s）</span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span>エリア：<b id="area">1</b>/5</span>
      </div>
      <div class="left">
        <button class="btn" id="startBtn">START</button>
        <!-- HTML（hrefはダミーに） -->
        <a class="btn ghost" href="#" id="backBtn">図鑑へ戻る</a>
        <button class="btn reset" id="resetCharBtn">キャラリセット</button>
      </div>
    </div>

    <canvas id="cv"></canvas>

    <!-- 成否オーバーレイ -->
    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="../dex/index.html">図鑑へ戻る</a>
        </div>
      </div>
    </div>
  </div>
  <div class="muted" style="margin-top:8px;line-height:1.6">
    操作：←→ 移動 ・ <b>SPACE</b> ジャンプ（コヨーテ 80ms）。<br/>
    タイルは踏むまで「未観測」。踏んだ瞬間に安全/崩壊が確率で決定（中心着地・水平進入ほど安全／高速着地は危険）。崩壊は0.35s遅延。  
    追加障害物：往復レーザーは<strong>点滅</strong>（ON時のみ接触判定）。隙を狙って抜けよう。
  </div>
</div>

<script>
/* ======= 図鑑連携：#69 を解放 ======= */
const SECRET_NO = 69;
const SECRET_FILE = 'secret_69.png';
function unlock69(){
  if (typeof unlockSecret === 'function'){
    unlockSecret(SECRET_NO, SECRET_FILE);
    return;
  }
  // フォールバック
  const DEX_KEY='dex_state_v1', id = 68; // 0始まり
  const dex = JSON.parse(localStorage.getItem(DEX_KEY)||'{}');
  dex.unlocked = Object.assign({}, dex.unlocked, {[id]:true});
  dex.secretFiles = Object.assign({}, dex.secretFiles, {[String(id)]:SECRET_FILE});
  if(!dex.selected) dex.selected = SECRET_FILE;
  localStorage.setItem(DEX_KEY, JSON.stringify(dex));
  try{ window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)})); }catch(_){}
}

/* ======= キャラリセット（選択スキンのみ初期化） ======= */
document.getElementById('resetCharBtn').addEventListener('click', ()=>{
  const ok = confirm('選択中のキャラを初期スキンに戻します。よろしいですか？（解放状況は消えません）');
  if(!ok) return;
  const DEX_KEY='dex_state_v1';
  const dex = JSON.parse(localStorage.getItem(DEX_KEY)||'{}');
  dex.selected = 'char.png';
  localStorage.setItem(DEX_KEY, JSON.stringify(dex));
  try{ window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)})); }catch(_){}
  alert('キャラを初期スキンに戻しました。');
});

/* ======= スクロール抑止（Arrow/Space） ======= */
window.addEventListener('keydown', (e)=>{
  const k = e.code;
  if (k==='ArrowUp'||k==='ArrowDown'||k==='ArrowLeft'||k==='ArrowRight'||k==='Space'){
    e.preventDefault();
  }
}, {passive:false});

/* ======= Canvas & DPI ======= */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', ()=>{ fitCanvas(); layoutArea(currentArea); drawScene(0); }, {passive:true});
fitCanvas();

/* ======= UI ======= */
const startBtn = document.getElementById('startBtn');
const timeEl   = document.getElementById('time');
const areaEl   = document.getElementById('area');
const ov       = document.getElementById('ov');
const ovMsg    = document.getElementById('ovMsg');
const ovSub    = document.getElementById('ovSub');
const retryBtn = document.getElementById('retryBtn');

/* ======= カメラ ======= */
let camX = 0, worldW = 0;
function clampCam(){
  const viewW = cv.clientWidth;
  camX = Math.max(0, Math.min(camX, Math.max(0, worldW - viewW)));
}

/* ======= 物理・ゲーム定数 ======= */
let playing=false, raf=0, t0=0, last=0, paused=false;
const TIME_LIMIT = 75;
const G = 1650;                    // 重力
const MOVE = 330;                  // 横移動
const JUMP_V = -540;               // ジャンプ
const COYOTE = 0.08;               // コヨーテ
const FRICTION = 0.9;              // 減衰
// 量子床パラメータ
const SAFE_BASE = 0.52;
const BONUS_CENTER_MAX = 0.10;
const BONUS_ANGLE_MAX  = 0.08;
const PENALTY_SPEED_MAX= 0.22;
const VY_REF = 760;
const TILE_BREAK_DELAY = 0.35;
// レーザー点滅（★追加調整：ON/OFFで必ず抜け道あり）
const LASER_PERIOD = 2.6; // s 一周期
const LASER_ON     = 1.15; // s ON時間
// エリア
const AREAS_TOTAL = 5;
let currentArea = 1;

// プレイヤー
let px=0, py=0, vx=0, vy=0, onGround=false, coyote=0;
let timer=0;
let platforms=[], tiles=[], lasers=[], goal=null, startPad=null;

/* ======= 入力 ======= */
const keys = {left:false, right:false, jump:false};
window.addEventListener('keydown', (e)=>{ if(e.repeat) return;
  if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = true;
  if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right= true;
  if (e.code==='Space'    ) keys.jump = true;
});
window.addEventListener('keyup', (e)=>{
  if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = false;
  if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right= false;
  if (e.code==='Space'    ) keys.jump = false;
});

/* ======= レイアウト ======= */
function unit(){ return Math.max(18, Math.min(42, cv.clientHeight/24)); }
function layoutArea(area){
  platforms=[]; tiles=[]; lasers=[]; camX=0;
  const U = unit();
  const groundY = cv.clientHeight - U*2;
  const startW = U*4;
  const tileW  = U*2.1, tileH = U*0.7, gapX = U*0.95;

  // スタート台
  startPad = {x: U*1.0, y: groundY, w: startW, h: U*0.8, type:'start'};
  platforms.push(startPad);

  // タイル列（エリアが進むほど長い）
  const cols = 10 + area*2; // 12,14,16,18,20
  let baseX = startPad.x + startPad.w + U*1.0;
  for (let i=0;i<cols;i++){
    const lane = (i%2===0)? 0 : 1;
    const tx = baseX + i*(tileW + gapX);
    const ty = groundY - U*(2.6 + lane*1.25 + Math.random()*0.7);
    tiles.push({
      x: tx, y: ty, w: tileW, h: tileH,
      observed:false, safe:null, breakAt:0, state:'unknown', shake:0
    });
  }

  // ゴール台（右端）
  const lastTile = tiles[tiles.length-1];
  goal = {x: lastTile.x + tileW + U*1.4, y: groundY - U*3.0, w: U*3.2, h: U*1.0, type:'goal'};
  platforms.push(goal);

  // レーザー（縦バー） ※本数/速度は従来通り
  const laserCount = 1 + Math.floor(area/2); // 1,1,2,2,3
  for (let i=0;i<laserCount;i++){
    const spanX1 = startPad.x + startPad.w + U*(2+i*3);
    const spanX2 = goal.x - U*(2+i*2);
    const y = groundY - U*(2.0 + Math.random()*2.6);
    const w = 8;
    const speed = 110 + area*25 + Math.random()*40;
    const phase = Math.random();
    lasers.push({
      x: spanX1 + (spanX2-spanX1)*phase, y, w, h: cv.clientHeight,
      minX: spanX1, maxX: spanX2, spd: (Math.random()<0.5?-1:1)*speed,
      // ★点滅用
      timer: Math.random()*LASER_PERIOD,
      active: false
    });
  }

  // ワールド幅（少し余白を足す）
  worldW = goal.x + U*6;

  // プレイヤー初期位置
  px = startPad.x + startPad.w*0.5 - U*0.5;
  py = startPad.y - U*2.1;
  vx = 0; vy = 0; onGround=true; coyote=0;

  clampCam();
}

/* ======= タイル観測 ======= */
function observeTile(t){
  if (t.observed) return;
  const speed = Math.sqrt(vx*vx + vy*vy);
  const horizRatio = Math.abs(vx) / (speed + 1e-6);
  const centerDx = Math.abs((px + PW()/2) - (t.x + t.w/2));
  const centerRate = 1 - Math.min(1, centerDx / (t.w/2));

  let pSafe = SAFE_BASE
            + centerRate * BONUS_CENTER_MAX
            + horizRatio * BONUS_ANGLE_MAX
            - Math.min(1, Math.abs(vy)/VY_REF) * PENALTY_SPEED_MAX;

  pSafe = Math.max(0.18, Math.min(0.84, pSafe));
  t.observed = true;

  const decoyChance = 0.05 + (currentArea-1)*0.02;
  if (Math.random() < decoyChance){
    t.safe = false;
    t.state = 'broken';
    return;
  }

  t.safe = Math.random() < pSafe;
  if (!t.safe){
    t.state = 'crack';
    t.breakAt = timer + TILE_BREAK_DELAY;
    t.shake = 1;
  }else{
    t.state = 'solid';
  }
}

/* ======= 衝突ヘルパ ======= */
function rectsOverlap(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}
function PR(){ return {x:px, y:py, w:PW(), h:PH()}; }
function PW(){ return unit()*1.2; }
function PH(){ return unit()*1.8; }

/* ======= 成否 ======= */
function fail(msg){
  playing=false;
  ovMsg.textContent = '失敗…';
  ovSub.textContent = msg || 'もう一度挑戦しよう';
  ov.style.display = 'grid';
}
function success(){
  playing=false;
  unlock69();
  ovMsg.textContent = '解放成功！ #69 が使えるようになった';
  ovSub.textContent = '図鑑で選択できます。';
  ov.style.display = 'grid';
}

/* ======= 進行 ======= */
function nextArea(){
  currentArea++;
  if (currentArea > AREAS_TOTAL){
    success(); return;
  }
  areaEl.textContent = currentArea;
  layoutArea(currentArea);
}

/* ======= ループ ======= */
function loop(ts){
  if (!playing) return;
  if (!last) last = ts;
  let dt = (ts - last)/1000; last = ts;
  timer = (ts - t0)/1000;
  timeEl.textContent = timer.toFixed(1);
  if (timer > TIME_LIMIT){ fail('時間切れ…'); return;}

  // 入力
  if (keys.left)  vx = -MOVE;
  if (keys.right) vx =  MOVE;
  if (!keys.left && !keys.right) vx *= FRICTION;

  // ジャンプ（コヨーテ）
  if (keys.jump){
    if (onGround || coyote > 0){
      vy = JUMP_V; onGround=false; coyote = 0; keys.jump = false;
    }
  }

  // 重力
  vy += G*dt;

  // 位置更新
  px += vx*dt;
  py += vy*dt;

  // 画面外 = 失敗
  if (py > cv.clientHeight + unit()*4 || px < -unit()*2 || px > worldW + unit()*2){
    fail('奈落に落ちた…'); return;
  }

  // 接地処理
  const player = PR();
  onGround = false;

  // スタート＆ゴール台
  for(const p of [startPad, goal]){
    if (!p) continue;
    const floor = {x:p.x, y:p.y, w:p.w, h:p.h};
    const prevBottom = player.y + player.h - vy*dt;
    if (player.x + player.w > floor.x && player.x < floor.x+floor.w){
      if (prevBottom <= floor.y && player.y + player.h >= floor.y){
        py = floor.y - player.h; vy = 0; onGround = true; coyote = COYOTE;
      }
    }
  }

  // タイル衝突＆観測
  for (const t of tiles){
    if (t.state === 'broken') continue;
    if (t.state === 'crack' && timer >= t.breakAt){ t.state = 'broken'; continue; }
    const prevBottom = player.y + player.h - vy*dt;
    if (player.x + player.w > t.x && player.x < t.x + t.w){
      if (prevBottom <= t.y && player.y + player.h >= t.y){
        observeTile(t);
        if (t.state !== 'broken'){
          py = t.y - player.h; vy = 0; onGround = true; coyote = COYOTE;
        }
      }
    }
  }

  // レーザー移動・点滅・当たり（★ここだけ変更）
  let hitLaser = false;
  lasers.forEach(L=>{
    // 往復移動
    L.x += L.spd*dt;
    if (L.x < L.minX){ L.x = L.minX; L.spd *= -1; }
    if (L.x > L.maxX){ L.x = L.maxX; L.spd *= -1; }

    // 点滅サイクル
    L.timer += dt;
    if (L.timer >= LASER_PERIOD) L.timer -= LASER_PERIOD;
    L.active = (L.timer < LASER_ON);

    if (L.active){
      const laserRect = {x:L.x - L.w/2, y:0, w:L.w, h:cv.clientHeight};
      if (rectsOverlap(PR(), laserRect)){ hitLaser = true; }
    }
  });
  if (hitLaser){ fail('レーザーに触れた…'); return; }

  // ゴール到達？
  if (rectsOverlap(PR(), goal)){ nextArea(); }

  // カメラ追従（プレイヤー中心寄りに）
  const targetCam = px - cv.clientWidth*0.45;
  camX += (targetCam - camX) * 0.15;
  clampCam();

  // 描画
  drawScene(dt);
  raf = requestAnimationFrame(loop);
}

/* ======= 描画 ======= */
function drawScene(dt){
  const w = cv.clientWidth, h=cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景
  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0, '#0f2238'); grad.addColorStop(1, '#0b1626');
  ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

  // 装飾グリッド
  ctx.strokeStyle = 'rgba(255,255,255,.06)';
  ctx.lineWidth = 1;
  for(let y=0;y<h;y+=unit()*2){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

  // スタート・ゴール
  [startPad, goal].forEach(p=>{
    if(!p) return;
    ctx.fillStyle = (p===goal)? '#10b981':'#334155';
    ctx.fillRect(p.x - camX, p.y, p.w, p.h);
  });

  // タイル
  tiles.forEach(t=>{
    let ox = 0;
    if (t.shake>0){ ox = (Math.random()*2-1)*2; t.shake = Math.max(0, t.shake - dt*3); }
    if (t.state==='unknown'){ ctx.fillStyle = '#475569'; }
    else if(t.state==='solid'){ ctx.fillStyle = '#64748b'; }
    else if(t.state==='crack'){ ctx.fillStyle = '#ef4444'; }
    else { ctx.fillStyle = 'rgba(239,68,68,.15)'; }
    ctx.fillRect(t.x+ox - camX, t.y, t.w, t.h);
    if (t.state==='crack'){
      ctx.strokeStyle = '#fde68a'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(t.x+4+ox - camX, t.y+2); ctx.lineTo(t.x+t.w-4+ox - camX, t.y+t.h-2); ctx.stroke();
    }
  });

  // レーザー（ONは強発光／OFFは薄表示）
  lasers.forEach(L=>{
    const x0 = (L.x - camX) - L.w/2;
    const g = ctx.createLinearGradient(x0,0,x0+L.w,0);
    if (L.active){
      g.addColorStop(0,'rgba(239,68,68,0)');
      g.addColorStop(0.5,'rgba(239,68,68,0.9)');
      g.addColorStop(1,'rgba(239,68,68,0)');
    }else{
      g.addColorStop(0,'rgba(239,68,68,0)');
      g.addColorStop(0.5,'rgba(239,68,68,0.25)');
      g.addColorStop(1,'rgba(239,68,68,0)');
    }
    ctx.fillStyle = g;
    ctx.fillRect(x0, 0, L.w, h);
  });

  // プレイヤー
  ctx.fillStyle = '#22d3ee';
  ctx.fillRect(px - camX, py, PW(), PH());
}

/* ======= 開始/再試行/初期化 ======= */
function resetAll(){
  playing=false; cancelAnimationFrame(raf);
  timer = 0; timeEl.textContent='0.0';
  currentArea = 1; areaEl.textContent = currentArea;
  ov.style.display='none';
  layoutArea(currentArea);
  drawScene(0);
}
function start(){
  resetAll();
  playing=true;
  t0 = performance.now(); last = t0; paused=false;
  raf = requestAnimationFrame(loop);
}
startBtn.addEventListener('click', start);
retryBtn.addEventListener('click', start);
document.addEventListener('visibilitychange', ()=>{ paused = document.hidden; });

/* 起動 */
resetAll();
</script>
</body>
</html>
