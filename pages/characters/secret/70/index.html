<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>シークレット挑戦 #70：終極試練（激むず10連）</title>
  <!-- 図鑑連携ヘルパ（存在すれば使う） -->
  <script src="../_unlock.js"></script>
  <style>
    :root{
      --bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;
      --accent:#f59e0b;--ok:#22c55e;--warn:#ef4444;--muted:#9ca3af
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:1100px;margin:24px auto;padding:16px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
    .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .left{display:flex;gap:10px;align-items:center}
    .btn{
      background:var(--accent);color:#221a05;border:none;border-radius:10px;
      padding:10px 14px;font-weight:800;cursor:pointer
    }
    .btn.ghost{background:#0ea5e9;color:#031423}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .muted{color:var(--muted);text-decoration:none}
    .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
    .stats{display:flex;gap:16px;align-items:center}
    canvas{
      display:block;width:100%;
      height:clamp(420px, calc(100svh - 260px), 800px);
      margin-top:10px;border-radius:12px;border:1px solid #1a2740;
      background:linear-gradient(#0f2238,#0b1626)
    }
    /* オーバーレイ */
    .overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45);z-index:3}
    .overlay .sheet{background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;display:grid;gap:10px;justify-items:center}
  </style>
</head>
<body>
<div class="wrap">
  <h1>シークレット挑戦 #70：終極試練（激むず 10 ステージ）</h1>
  <div class="panel">
    <div class="row">
      <div class="stats">
        <span class="badge">現在：<b id="stage">1</b> / 10</span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span id="cond" class="muted">条件はステージ毎に表示</span>
      </div>
      <div class="left" style="margin-left:-6px">
        <button class="btn" id="startBtn">START</button>
        <a class="btn ghost" href="#" id="backBtn">図鑑へ戻る</a>
      </div>
    </div>

    <canvas id="cv"></canvas>

    <!-- 成否オーバーレイ -->
    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" href="#" id="backBtn2">図鑑へ戻る</a>
        </div>
      </div>
    </div>
  </div>
  <div class="muted" style="margin-top:8px;line-height:1.6">
    操作：←→ 移動 ・ <b>SPACE</b> ジャンプ（コヨーテ 90ms）。<br/>
    レーザーは“移動式”のみ。ステージによって目標（時間・コイン・ゴール到達など）が変わります。
  </div>
</div>

<script>
/* =================== 共通：図鑑パス解決 & 解放 =================== */
function resolveDexPath(){
  const p = location.pathname;
  if (p.includes('/pages/characters/secret/')) return '../../dex/index.html';
  if (p.includes('/pages/characters/'))        return 'dex/index.html';
  if (p.includes('/pages/'))                   return 'characters/dex/index.html';
  return '/pages/characters/dex/index.html';
}
for (const id of ['backBtn','backBtn2']){
  const a = document.getElementById(id);
  if (a){
    const href = resolveDexPath();
    a.setAttribute('href', href);
    a.addEventListener('click', (e)=>{ e.preventDefault(); location.href = href; });
  }
}

// 解放ヘルパ
function unlock70(){
  if (typeof unlockSecret === 'function'){
    unlockSecret(70, 'secret_70.png'); return;
  }
  const DEX_KEY='dex_state_v1', id = 69; // 0始まり: 70→69
  const dex = JSON.parse(localStorage.getItem(DEX_KEY)||'{}');
  dex.unlocked   = Object.assign({}, dex.unlocked, {[id]:true});
  dex.secretFiles= Object.assign({}, dex.secretFiles, {[String(id)]:'secret_70.png'});
  if (!dex.selected) dex.selected = 'secret_70.png';
  localStorage.setItem(DEX_KEY, JSON.stringify(dex));
  try{ window.dispatchEvent(new StorageEvent('storage',{key:DEX_KEY,newValue:JSON.stringify(dex)})); }catch(_){}
}

/* =================== スクロール抑止（矢印/Space） =================== */
window.addEventListener('keydown', (e)=>{
  const k = e.code;
  if (k==='ArrowUp'||k==='ArrowDown'||k==='ArrowLeft'||k==='ArrowRight'||k==='Space'){
    e.preventDefault();
  }
}, {passive:false});

/* =================== Canvas & DPI =================== */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', ()=>{ fitCanvas(); }, {passive:true});
fitCanvas();

/* =================== UI =================== */
const startBtn = document.getElementById('startBtn');
const retryBtn = document.getElementById('retryBtn');
const timeEl   = document.getElementById('time');
const stageEl  = document.getElementById('stage');
const condEl   = document.getElementById('cond');
const ov       = document.getElementById('ov');
const ovMsg    = document.getElementById('ovMsg');
const ovSub    = document.getElementById('ovSub');

/* =================== 入力 =================== */
const keys = {left:false, right:false, jump:false};
window.addEventListener('keydown', (e)=>{ if(e.repeat) return;
  if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = true;
  if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right= true;
  if (e.code==='Space'    ) keys.jump = true;
});
window.addEventListener('keyup', (e)=>{
  if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = false;
  if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right= false;
  if (e.code==='Space'    ) keys.jump = false;
});
document.addEventListener('visibilitychange', ()=>{ paused = document.hidden; });

/* =================== 物理・パラメータ =================== */
function U(){ return Math.max(18, Math.min(42, cv.clientHeight/22)); } // 基本ユニット
const PWk=1.2, PHk=1.8; // player size in U
const G = 1650, MOVE = 340, JUMP_V=-540, COYOTE=0.09, FRICTION=0.90;

let playing=false, raf=0, t0=0, last=0, paused=false;
let stageIdx=1, timer=0, camX=0, worldW=2000;
let px=0, py=0, vx=0, vy=0, onGround=false, coyote=0;

function PW(){ return U()*PWk; }
function PH(){ return U()*PHk; }
function PR(){ return {x:px, y:py, w:PW(), h:PH()}; }
function rectOverlap(a,b){ return !(a.x+a.w<b.x||a.x>b.x+b.w||a.y+a.h<b.y||a.y>b.y+b.h); }

/* =================== エンティティ =================== */
let platforms=[], tiles=[], lasers=[], coins=[], spikes=[], goal=null;
let runner = null;  // {scrollVX, timeNeed, coinNeed, spawnTimer}
let survival = null;// {timeNeed, spawnTimer}

function clearEntities(){ platforms=[]; tiles=[]; lasers=[]; coins=[]; spikes=[]; goal=null; runner=null; survival=null; }

/* =================== ステージセット =================== */
/* ステージタイプ：
   1 Runner(8s/10coins)    2 Tiles(中)      3 LaserMaze(1)
   4 Survival(10s)         5 Runner(10s/15) 6 Tiles(長)
   7 LaserMaze(2)          8 Survival+Laser(12s)
   9 Precision+Laser       10 Gauntlet(総合)
*/

function setCondition(text){ condEl.textContent = text; }

function buildRunner({sec=8, coinsNeed=10, speed=260, endSpeed=420}){
  clearEntities();
  const h = cv.clientHeight, groundY = h - U()*2;
  // 地面帯
  platforms.push({x:0,y:groundY,w:999999,h:U()*0.9,type:'ground'});
  // ランダム障害物とコインは移動式ステージとして spawn
  runner = {timeNeed:sec, coinNeed:coinsNeed, scrollVX:speed, endSpeed, spawnTimer:0};
  // 初期位置
  px = U()*3; py = groundY - PH(); vx=0; vy=0; onGround=true; coyote=0;
  worldW = 999999; // 無限相当
  setCondition(`条件：${sec}s 生存 ＋ コイン ${coinsNeed}枚`);
}
function spawnRunnerPack(speedK=1){
  const h = cv.clientHeight, gy = h - U()*2;
  const roll = Math.random();
  if (roll < 0.5){
    // ブロック・ジャンプ強要
    const w = U()*(1.2 + Math.random()*1.2);
    const hh= U()*(1.1 + Math.random()*2.2);
    platforms.push({x:camX + cv.clientWidth + U()*1.2, y:gy-hh, w, h:hh, type:'wall'});
    // 上にコイン
    if (Math.random()<0.7){
      coins.push({x:camX + cv.clientWidth + U()*1.2 + w/2, y:gy-hh - U()*1.2, r:U()*0.45, taken:false});
    }
  }else{
    // スパイク列
    const w = U()*(1.8 + Math.random()*1.8);
    spikes.push({x:camX + cv.clientWidth + U()*1.2, y:gy - U()*0.8, w, h:U()*0.8, type:'spike'});
    // 手前上空コイン
    coins.push({x:camX + cv.clientWidth + U()*0.9, y:gy - U()*2.4, r:U()*0.45, taken:false});
    if (Math.random()<0.5){
      coins.push({x:camX + cv.clientWidth + U()*1.2 + w*0.7, y:gy - U()*2.6, r:U()*0.45, taken:false});
    }
  }
}

function buildTiles({cols=16}){
  clearEntities();
  const h = cv.clientHeight, groundY = h - U()*2;
  const start = {x:U()*1.0, y:groundY, w:U()*4, h:U()*0.9};
  platforms.push(start);
  let baseX = start.x + start.w + U()*1.0;
  for (let i=0;i<cols;i++){
    const lane = (i%2===0)? 0 : 1;
    const tx = baseX + i*(U()*2.1 + U()*1.0);
    const ty = groundY - U()*(2.8 + lane*1.15 + Math.random()*0.7);
    tiles.push({x:tx,y:ty,w:U()*2.1,h:U()*0.75,observed:false,safe:null,breakAt:0,state:'unknown',shake:0});
  }
  const last = tiles[tiles.length-1];
  goal = {x:last.x + U()*2.1 + U()*1.2, y:groundY - U()*3.0, w:U()*3.0, h:U()*1.0};
  // レーザー少量（移動式）
  const minX = start.x + start.w + U()*4, maxX = goal.x - U()*4;
  const count = Math.max(1, Math.floor(cols/8));
  for(let i=0;i<count;i++){
    const y = groundY - U()*(2.0 + Math.random()*2.8);
    const w = U()*0.35;
    const spd = 110 + Math.random()*80;
    const phase = Math.random();
    lasers.push({x:minX + (maxX-minX)*phase, y, w, h:cv.clientHeight, minX, maxX, spd:(Math.random()<0.5?-1:1)*spd});
  }
  // 初期位置
  px = start.x + start.w*0.5 - PW()/2; py = start.y - PH(); vx=0; vy=0; onGround=true; coyote=0;
  worldW = goal.x + U()*6;
  setCondition(`条件：ゴール到達（量子床：踏むまで安全不明。割れる床は0.35s後に崩落）`);
}

const SAFE_BASE=0.54, BONUS_C=0.12, BONUS_A=0.08, PEN_V=0.18, VY_REF=760, BREAK_DELAY=0.35;
function observeTile(t){
  if (t.observed) return;
  const speed = Math.sqrt(vx*vx+vy*vy), horiz = Math.abs(vx)/(speed+1e-6);
  const cx = Math.abs((px+PW()/2)-(t.x+t.w/2)); const centerRate = 1 - Math.min(1, cx/(t.w/2));
  let pSafe = SAFE_BASE + centerRate*BONUS_C + horiz*BONUS_A - Math.min(1, Math.abs(vy)/VY_REF)*PEN_V;
  pSafe = Math.max(0.2, Math.min(0.9, pSafe));
  t.observed = true;
  // 稀に即落ち（抑えめ）
  if (Math.random() < 0.04){ t.safe=false; t.state='broken'; return; }
  t.safe = Math.random() < pSafe;
  if (!t.safe){ t.state='crack'; t.breakAt = timer + BREAK_DELAY; t.shake=1; } else t.state='solid';
}

function buildLaserMaze({segments=3}){
  clearEntities();
  const h = cv.clientHeight, groundY = h - U()*2;
  // 段差プラットフォーム列
  let x = U()*2, y=groundY - U()*2.8;
  for(let i=0;i<segments;i++){
    const w = U()*(4.6 + Math.random()*2.0);
    platforms.push({x, y, w, h:U()*0.9, type:'p'});
    // 上空に横レーザー（左右往復）
    const minX = x + U()*0.6, maxX = x + w - U()*0.6;
    const ly = y - U()*(1.6 + Math.random()*1.2);
    const lw = U()*0.35, spd= 130 + i*30 + Math.random()*40;
    lasers.push({x:(minX+maxX)/2, y:ly, w:lw, h:U()*0.35, minX, maxX, spd:(Math.random()<0.5?-1:1)*spd, horiz:true});
    // 次の台座
    x += w + U()*2.2;
    y = groundY - U()*(2.0 + Math.random()*4.0);
  }
  goal = {x:x+U()*1.2, y:groundY - U()*3.0, w:U()*3.0, h:U()*1.0};
  worldW = goal.x + U()*6;
  // 初期位置
  const start = {x:U()*1.0, y:groundY, w:U()*4, h:U()*0.9};
  platforms.push(start);
  px = start.x + start.w*0.5 - PW()/2; py = start.y - PH(); onGround=true; vx=vy=0; coyote=0;
  setCondition(`条件：ゴール到達（移動レーザーに接触すると失敗）`);
}

function buildSurvival({sec=10, withLaser=false}){
  clearEntities();
  const w = Math.max(cv.clientWidth, U()*28), h = cv.clientHeight;
  const gy = h - U()*2;
  // 床・左壁・右壁
  platforms.push({x:0,y:gy,w:999999,h:U()*0.9,type:'ground'});
  platforms.push({x:-U()*2,y:0,w:U()*2,h:999999,type:'wallL'});
  platforms.push({x: w+U()*2, y:0, w:U()*2, h:999999, type:'wallR'});
  survival = {timeNeed:sec, spawnTimer:0, withLaser};
  // レーザー（縦が左右に往復）1〜2本
  if (withLaser){
    const minX = U()*2, maxX = w - U()*2;
    const count = 2;
    for(let i=0;i<count;i++){
      const ly = 0, lw = U()*0.35, spd = 120 + Math.random()*60;
      const phase = Math.random();
      lasers.push({x:minX + (maxX-minX)*phase, y:ly, w:lw, h:h, minX, maxX, spd:(Math.random()<0.5?-1:1)*spd});
    }
  }
  // 初期
  worldW = w;
  px = U()*4; py = gy - PH(); onGround=true; vx=vy=0; coyote=0;
  setCondition(`条件：${sec}s 生存${withLaser?'（＋移動レーザー回避）':''}`);
}
function spawnFallingSpike(){
  const x = camX + Math.random()*cv.clientWidth + U()*2;
  const w = U()*0.9, h = U()*0.9;
  spikes.push({x, y:-U()*2, w, h, vy: 220 + Math.random()*180});
}

function buildPrecision(){
  clearEntities();
  const gy = cv.clientHeight - U()*2;
  const start = {x:U()*1.0, y:gy, w:U()*4, h:U()*0.9};
  platforms.push(start);
  let x = start.x + start.w + U()*1.2;
  // 細め足場+下スパイク
  for(let i=0;i<8;i++){
    const w = U()*(2.0 + Math.random()*0.8);
    const y = gy - U()*(2.4 + (i%2?1.4:0.8) + Math.random()*1.0);
    platforms.push({x, y, w, h:U()*0.8});
    spikes.push({x, y:gy - U()*0.8, w, h:U()*0.8});
    // 横レーザー（足場間）
    if (i%2===1){
      const minX = x - U()*3.0, maxX = x + w + U()*1.0;
      const ly = y - U()*1.0;
      lasers.push({x:(minX+maxX)/2, y:ly, w:U()*0.35, h:U()*0.35, minX, maxX, spd:(Math.random()<0.5?-1:1)*(130+Math.random()*50), horiz:true});
    }
    x += w + U()*2.4;
  }
  goal = {x:x + U()*1.6, y:gy - U()*3.0, w:U()*3.0, h:U()*1.0};
  worldW = goal.x + U()*6;
  px = start.x + start.w/2 - PW()/2; py=start.y - PH(); vx=vy=0; onGround=true; coyote=0;
  setCondition('条件：ゴール到達（狭い足場＋移動レーザー＋下スパイク）');
}

function buildGauntlet(){
  clearEntities();
  const gy = cv.clientHeight - U()*2;
  const start = {x:U()*1.0, y:gy, w:U()*4, h:U()*0.9};
  platforms.push(start);
  let x = start.x + start.w + U()*1.2;

  // 区間1：Runner風障害
  for(let i=0;i<6;i++){
    const w = U()*(1.4 + Math.random()*1.4);
    const hh= U()*(1.2 + Math.random()*2.2);
    platforms.push({x:x + i*(U()*3.2), y:gy-hh, w, h:hh});
    if (Math.random()<0.6) coins.push({x:x + i*(U()*3.2)+w/2, y:gy-hh-U()*1.6, r:U()*0.45, taken:false});
  }
  x += U()*3.2*6 + U()*2;

  // 区間2：量子床短め
  const cols=10;
  for(let i=0;i<cols;i++){
    const tx = x + i*(U()*2.1 + U()*0.9);
    const ty = gy - U()*(2.6 + (i%2?1.2:0.6) + Math.random()*0.6);
    tiles.push({x:tx,y:ty,w:U()*2.1,h:U()*0.75,observed:false,safe:null,breakAt:0,state:'unknown',shake:0});
  }
  x += (U()*2.1 + U()*0.9)*cols + U()*2.0;

  // 区間3：レーザー回廊
  for(let i=0;i<4;i++){
    const w = U()*(4.4 + Math.random()*1.6);
    const y = gy - U()*(2.0 + Math.random()*3.0);
    platforms.push({x:x, y, w, h:U()*0.9});
    const minX=x+U()*0.6, maxX=x+w-U()*0.6, ly=y-U()*(1.4+Math.random()*1.0);
    lasers.push({x:(minX+maxX)/2, y:ly, w:U()*0.35, h:U()*0.35, minX, maxX, spd:(Math.random()<0.5?-1:1)*(140+Math.random()*40), horiz:true});
    x += w + U()*2.0;
  }

  goal = {x:x + U()*2.0, y:gy - U()*3.0, w:U()*3.0, h:U()*1.0};
  worldW = goal.x + U()*6;
  px = start.x + start.w/2 - PW()/2; py = start.y - PH(); vx=vy=0; onGround=true; coyote=0;
  setCondition('条件：ゴール到達（総合：Runner→量子床→レーザー）');
}

/* ===== ステージビルダー一覧（1..10） ===== */
const STAGES = [
  ()=>buildRunner({sec:8,  coinsNeed:10, speed:260, endSpeed:400}),   // 1
  ()=>buildTiles({cols:16}),                                          // 2
  ()=>buildLaserMaze({segments:3}),                                   // 3
  ()=>buildSurvival({sec:10, withLaser:false}),                       // 4
  ()=>buildRunner({sec:10, coinsNeed:15, speed:300, endSpeed:440}),   // 5
  ()=>buildTiles({cols:20}),                                          // 6
  ()=>buildLaserMaze({segments:5}),                                   // 7
  ()=>buildSurvival({sec:12, withLaser:true}),                        // 8
  ()=>buildPrecision(),                                               // 9
  ()=>buildGauntlet(),                                                // 10
];

/* =================== 進行制御 =================== */
function startGame(){
  stageIdx = 1; timer=0; camX=0; playing=true; last=t0=performance.now();
  STAGES[0](); stageEl.textContent = stageIdx; ov.style.display='none';
  raf = requestAnimationFrame(loop);
}
function nextStage(){
  stageIdx++;
  if (stageIdx>10){ // クリア！
    playing=false; cancelAnimationFrame(raf);
    unlock70();
    ovMsg.textContent = '完全制覇！ #70 解放';
    ovSub.textContent = '図鑑で選択できます。';
    ov.style.display='grid';
    return;
  }
  STAGES[stageIdx-1]();
  stageEl.textContent = stageIdx;
}

function fail(msg){
  playing=false; cancelAnimationFrame(raf);
  ovMsg.textContent = '失敗…';
  ovSub.textContent = msg || 'もう一度挑戦しよう';
  ov.style.display='grid';
}

/* =================== ループ =================== */
function loop(ts){
  if (!playing) return;
  if (!last) last = ts;
  const dt = Math.min(0.033, (ts - last)/1000); last = ts;
  timer = (ts - t0)/1000;
  timeEl.textContent = timer.toFixed(1);

  // 入力
  if (keys.left)  vx = -MOVE;
  if (keys.right) vx =  MOVE;
  if (!keys.left && !keys.right) vx *= FRICTION;
  if (keys.jump){
    if (onGround || coyote>0){ vy = JUMP_V; onGround=false; coyote=0; keys.jump=false; }
  }

  // 重力
  vy += G*dt;

  // Runner のときは“世界が流れる”
  if (runner){
    const k = Math.min(1, timer/runner.timeNeed);
    const sc = runner.scrollVX + (runner.endSpeed-runner.scrollVX)*k;
    camX += sc*dt * 0.75; // 画面もやや押される
    // スポーン
    runner.spawnTimer += dt;
    const spawnInt = Math.max(0.55, 0.95 - 0.03*timer);
    if (runner.spawnTimer >= spawnInt){ runner.spawnTimer=0; spawnRunnerPack(k); }
    // コイン・障害を左に流す（カメラ押しに対する見かけ速度調整）
    const flow = sc*dt;
    [platforms, spikes, coins].forEach(arr=>{
      arr.forEach(o=>{ if (!o.static) o.x -= flow*0.25; }); // 少しだけ流れる
    });
  }

  // 位置更新
  px += vx*dt;
  py += vy*dt;

  // 画面外で失敗（Survival は左右壁があるので下落のみ）
  if (py > cv.clientHeight + U()*4 || px < -U()*6 || px > worldW + U()*6){ fail('奈落に落ちた…'); return; }

  // 接地判定
  const P = PR(); onGround=false;
  for (const p of platforms){
    const prevBottom = P.y + P.h - vy*dt;
    if (P.x + P.w > p.x && P.x < p.x + p.w){
      if (prevBottom <= p.y && P.y + P.h >= p.y){
        py = p.y - P.h; vy = 0; onGround=true; coyote = COYOTE;
      }
    }
  }

  // 量子床（踏む→判定→割れるまで待つ）
  for (const t of tiles){
    if (t.state==='broken') continue;
    if (t.state==='crack' && timer >= t.breakAt){ t.state='broken'; continue; }
    const prevBottom = P.y + P.h - vy*dt;
    if (P.x + P.w > t.x && P.x < t.x + t.w){
      if (prevBottom <= t.y && P.y + P.h >= t.y){
        observeTile(t);
        if (t.state!=='broken'){ py = t.y - P.h; vy=0; onGround=true; coyote=COYOTE; }
      }
    }
  }

  // コイン
  for (const c of coins){
    if (c.taken) continue;
    const dx = Math.abs((c.x) - (P.x + P.w/2));
    const dy = Math.abs((c.y) - (P.y + P.h/2));
    if (dx < (P.w/2 + c.r) && dy < (P.h/2 + c.r)) c.taken = true;
  }

  // レーザー（全て移動式）
  lasers.forEach(L=>{
    if (L.horiz){ // 横レーザー（左右往復）
      L.x += L.spd*dt;
      if (L.x < L.minX){ L.x=L.minX; L.spd*=-1; }
      if (L.x > L.maxX){ L.x=L.maxX; L.spd*=-1; }
      const r = {x:L.x - U()*0.2, y:L.y - U()*6, w:U()*0.4, h:U()*12}; // 横でも棒状に厚み
      if (rectOverlap(PR(), r)) { fail('レーザーに触れた…'); return; }
    }else{
      L.x += L.spd*dt;
      if (L.x < L.minX){ L.x=L.minX; L.spd*=-1; }
      if (L.x > L.maxX){ L.x=L.maxX; L.spd*=-1; }
      const r = {x:L.x - L.w/2, y:0, w:L.w, h:cv.clientHeight};
      if (rectOverlap(PR(), r)) { fail('レーザーに触れた…'); return; }
    }
  });

  // スパイク衝突
  for (const s of spikes){
    if (s.vy){ s.y += s.vy*dt; } // survival の落下
    if (rectOverlap(PR(), s)){ fail('トゲに当たった…'); return; }
  }

  // Survival の落下物生成
  if (survival){
    survival.spawnTimer += dt;
    const intv = 0.28; // 落下頻度
    if (survival.spawnTimer >= intv){ survival.spawnTimer=0; spawnFallingSpike(); }
    // 成功判定
    if (timer >= survival.timeNeed){ nextStage(); return; }
  }

  // Runner 成功判定
  if (runner){
    const needCoins = runner.coinNeed;
    const got = coins.filter(c=>c.taken).length;
    setCondition(`条件：${runner.timeNeed}s 生存 ＋ コイン ${needCoins}枚（現在 ${got}）`);
    if (timer >= runner.timeNeed && got >= needCoins){ nextStage(); return; }
  }

  // ゴール
  if (goal && rectOverlap(PR(), goal)){ nextStage(); return; }

  // カメラ（追従＆クランプ）
  const view = cv.clientWidth;
  const target = Math.max(0, Math.min(px - view*0.35, worldW - view + U()*4));
  camX += (target - camX)*0.12;

  // 描画
  draw();
  raf = requestAnimationFrame(loop);
}

/* =================== 描画 =================== */
function draw(){
  const w = cv.clientWidth, h = cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景グラデ＆グリッド
  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0,'#0f2238'); grad.addColorStop(1,'#0b1626');
  ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
  ctx.strokeStyle='rgba(255,255,255,.06)'; ctx.lineWidth=1;
  for(let y=0;y<h;y+=U()*2){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

  ctx.save();
  ctx.translate(-camX, 0);

  // 床・足場
  platforms.forEach(p=>{
    ctx.fillStyle = '#334155';
    if (p.type==='ground') ctx.fillStyle = '#0e243a';
    ctx.fillRect(p.x, p.y, p.w, p.h);
  });

  // 量子床
  tiles.forEach(t=>{
    let ox=0; if (t.shake>0){ ox=(Math.random()*2-1)*2; t.shake=Math.max(0,t.shake-0.08); }
    if (t.state==='unknown') ctx.fillStyle='#475569';
    else if (t.state==='solid') ctx.fillStyle='#64748b';
    else if (t.state==='crack') ctx.fillStyle='#ef4444';
    else ctx.fillStyle='rgba(239,68,68,.18)';
    ctx.fillRect(t.x+ox, t.y, t.w, t.h);
    if (t.state==='crack'){
      ctx.strokeStyle='#fde68a'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(t.x+4+ox,t.y+2); ctx.lineTo(t.x+t.w-4+ox,t.y+t.h-2); ctx.stroke();
    }
  });

  // コイン
  coins.forEach(c=>{
    if (c.taken) return;
    ctx.beginPath(); ctx.arc(c.x, c.y, c.r, 0, Math.PI*2); ctx.closePath();
    ctx.fillStyle='#fbbf24'; ctx.fill();
    ctx.strokeStyle='#fde68a'; ctx.lineWidth=2; ctx.stroke();
  });

  // スパイク
  spikes.forEach(s=>{
    ctx.fillStyle='#ef4444';
    ctx.beginPath();
    ctx.moveTo(s.x, s.y+s.h);
    ctx.lineTo(s.x+s.w, s.y+s.h);
    ctx.lineTo(s.x+s.w*0.5, s.y);
    ctx.closePath(); ctx.fill();
  });

  // レーザー（全て移動式）
  lasers.forEach(L=>{
    const x0 = L.x - (L.horiz?U()*0.2:L.w/2);
    const ww = L.horiz? U()*0.4 : L.w;
    const g = ctx.createLinearGradient(x0,0,x0+ww,0);
    g.addColorStop(0,'rgba(239,68,68,0)');
    g.addColorStop(0.5,'rgba(239,68,68,0.9)');
    g.addColorStop(1,'rgba(239,68,68,0)');
    ctx.fillStyle=g;
    if (L.horiz){
      ctx.fillRect(x0, L.y - U()*6, ww, U()*12);
    }else{
      ctx.fillRect(x0, 0, ww, h);
    }
  });

  // ゴール
  if (goal){
    ctx.fillStyle='#10b981';
    ctx.fillRect(goal.x, goal.y, goal.w, goal.h);
  }

  // プレイヤー
  ctx.fillStyle='#22d3ee';
  ctx.fillRect(px, py, PW(), PH());

  ctx.restore();
}

/* =================== 起動・操作 =================== */
startBtn.addEventListener('click', startGame);
retryBtn.addEventListener('click', startGame);

// 初期レイアウトだけ軽く描画
STAGES[0](); // 条件表示のため一度呼ぶが playing=false のまま
playing=false;
draw();
</script>
</body>
</html>
