<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Secret #70：ULTIMATE 10（激むず）</title>
<style>
  :root{
    --bg:#0b1220;--ink:#e5e7eb;--card:#111827;--line:#243042;
    --accent:#f59e0b;--ok:#22c55e;--warn:#ef4444;--muted:#9ca3af
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    overscroll-behavior: none; /* Space/矢印でのスクロールを抑える */
  }
  .wrap{max-width:1100px;margin:24px auto;padding:16px}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;position:relative}
  .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .left{display:flex;gap:10px;align-items:center}
  .right{display:flex;gap:16px;align-items:center}
  .btn{
    background:var(--accent);color:#221a05;border:none;border-radius:10px;
    padding:10px 14px;font-weight:800;cursor:pointer;text-decoration:none;display:inline-block
  }
  .btn.ghost{background:#0ea5e9;color:#031423}
  .btn.red{background:#ef4444;color:#120606}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .muted{color:var(--muted);text-decoration:none}
  .badge{background:#0b1626;border:1px solid #1a2740;border-radius:999px;padding:6px 10px;font-weight:700}
  canvas{
    display:block;width:100%;
    height:clamp(380px, calc(100svh - 260px), 720px);
    margin-top:10px;
    background:linear-gradient(#0f2238,#0b1626);
    border-radius:12px;border:1px solid #1a2740
  }
  @media (max-width:640px){ canvas{height:440px} }

  .overlay{
    position:absolute;inset:0;display:none;place-items:center;
    background:rgba(0,0,0,.45)
  }
  .overlay .sheet{
    background:#111827;border:1px solid #243042;border-radius:14px;padding:16px;min-width:60%;
    display:grid;gap:12px;justify-items:center
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>Secret #70：ULTIMATE 10（激むず）</h1>
  <div class="panel">
    <div class="row">
      <div class="left">
        <button class="btn" id="startBtn">START</button>
        <a class="btn ghost" id="backLink" href="#">図鑑へ戻る</a>
        <button class="btn red" id="resetBtn" title="#70 の解放状態だけ初期化">#70解放リセット</button>
      </div>
      <div class="right">
        <span class="badge">10ステージ連結 / 3キーでゲート開放</span>
        <span>タイム：<b id="time">0.0</b>s</span>
        <span>進捗：<b id="prog">0</b>%</span>
        <span>KEY：<b id="keys">0</b>/3</span>
      </div>
    </div>

    <canvas id="cv"></canvas>

    <div class="overlay" id="ov">
      <div class="sheet">
        <div id="ovMsg" style="font-weight:800;font-size:18px"></div>
        <div class="muted" id="ovSub"></div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center">
          <button class="btn" id="retryBtn">もう一度</button>
          <a class="btn ghost" id="backLink2" href="#">図鑑へ</a>
        </div>
      </div>
    </div>
  </div>

  <div class="muted" style="margin-top:8px;line-height:1.6">
    操作：<b>SPACE / 画面タップ</b>でジャンプ（<b>2段ジャンプ</b>）。  
    スクロールは自動。各ステージの仕掛け（ピット・壁・ドローン・レーザー・崩落足場・上昇気流・落下爆弾・横レーザー等）を突破し、<b>3つのキー</b>を集めて最後のゲートを開け！
  </div>
</div>

<script>
/* ===== ルーティング：図鑑戻り先を自動解決 ===== */
function resolveDexPath(){
  const p = location.pathname;
  if (p.includes('/pages/characters/secret/')) return '../../dex/index.html';
  if (p.includes('/pages/characters/'))       return '../dex/index.html';
  if (p.includes('/pages/'))                  return 'characters/dex/index.html';
  return 'pages/characters/dex/index.html';
}
document.getElementById('backLink').href  = resolveDexPath();
document.getElementById('backLink2').href = resolveDexPath();

/* ===== DEX：#70 解放 / リセット ===== */
const DEX_KEY   = 'dex_state_v1';
const SECRET_ID = 69;               // 0始まり → #70
const SECRET_FN = 'secret_70.png';  // project-root に配置

function loadDex(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY)||'{}'); }catch{ return {}; } }
function saveDex(v){ localStorage.setItem(DEX_KEY, JSON.stringify(v||{})); }
function grantSecret70(){
  const dex = loadDex();
  dex.unlocked    = Object.assign({}, dex.unlocked, { [SECRET_ID]: true });
  dex.secretFiles = Object.assign({}, dex.secretFiles, { [SECRET_ID]: SECRET_FN });
  if (!dex.selected) dex.selected = SECRET_FN;
  saveDex(dex);
  try{ window.dispatchEvent(new StorageEvent('storage', {key:DEX_KEY, newValue:JSON.stringify(dex)})); }catch(_){}
}
function resetSecret70(){
  const dex = loadDex();
  if (dex.unlocked)    delete dex.unlocked[SECRET_ID];
  if (dex.secretFiles) delete dex.secretFiles[SECRET_ID];
  saveDex(dex);
  try{ window.dispatchEvent(new StorageEvent('storage', {key:DEX_KEY, newValue:JSON.stringify(dex)})); }catch(_){}
}

/* ===== Canvas（高DPI） ===== */
const cv  = document.getElementById('cv');
const ctx = cv.getContext('2d');
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = cv.clientWidth, h = cv.clientHeight;
  cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', fitCanvas, {passive:true});
fitCanvas();

/* ===== スクロール抑止（Space/矢印） ===== */
addEventListener('keydown', (e)=>{
  if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
}, {passive:false});

/* ===== DOM ===== */
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const timeEl   = document.getElementById('time');
const progEl   = document.getElementById('prog');
const keysEl   = document.getElementById('keys');
const ov       = document.getElementById('ov');
const ovMsg    = document.getElementById('ovMsg');
const ovSub    = document.getElementById('ovSub');
const retryBtn = document.getElementById('retryBtn');

/* ===== ゲーム定数（超高難度・到達可能バランス） ===== */
const GROUND_H   = 30;
const PW=22, PH=26;
const GRAVITY = 1500;
const JUMP_V  = -540;      // 1段目
const DJUMP_V = -520;      // 2段目
const SPEED   = 275;       // 固定速度
const HIT_F   = 2;         // 当たり判定の緩め
const COYOTE  = 0.08;      // コヨーテタイム[s]
const UNIT    = () => Math.max(24, Math.floor(cv.clientHeight/14));

/* 仕掛けパラメータ */
const GATE_W = 16;
const L_PERIOD = 2.3, L_OFF = 0.9;  // レーザー停止窓（突破可能に）
const SAW_R = 12;
const BOMB_SPD = 260;               // ボム落下速度
const UPDRAFT_V = -380;             // 上昇気流の追加加速度

/* ===== 状態 ===== */
let playing=false, t0=0, last=0, raf=0;
let px=90, py=0, vy=0, onGround=false, jumps=2, coyote=0;
let camX=0, timeNow=0, prog=0, keys=0;

/* ステージ・ワールド */
let WORLD_LEN=0;
let pits=[], walls=[], drones=[], lasers=[], plats=[], updrafts=[], bombs=[], xlasers=[], keysArr=[], gate=null, goal=null;

/* ===== 床Y ===== */
function groundY(){ return cv.clientHeight - GROUND_H; }

/* ===== ステージビルド（10連） ===== */
function buildStage(){
  pits.length=walls.length=drones.length=lasers.length=plats.length=updrafts.length=bombs.length=xlasers.length=keysArr.length=0;
  gate=goal=null; keys=0; keysEl.textContent='0';

  const H = groundY();
  let X = 0;

  function addPit(x,w){ pits.push({x,w}); }
  function addWall(x,w,h){ walls.push({x,w,h}); } // 床からの柱
  function addDrone(x,baseY,amp){ drones.push({x,baseY,amp,t:0}); }
  function addLaser(x,phase){ lasers.push({x,phase,period:L_PERIOD,off:L_OFF}); }
  function addPlat(x,y,w){ plats.push({x,y,w,h:10,ttl:-1,fragile:false}); }
  function addFragile(x,y,w){ plats.push({x,y,w,h:10,ttl:0.35,fragile:true,hit:false}); } // 乗ると消える
  function addUp(x,w){ updrafts.push({x,w}); }
  function addBomb(x,delay){ bombs.push({x,y:-40,delay,v:BOMB_SPD,armed:false}); }
  function addXLaser(x,y,w,period,off,phase){ xlasers.push({x,y,w,period,off,phase}); }
  function addKey(x,y){ keysArr.push({x,y,r:10,taken:false}); }

  // --- Stage 1: ピット&トゲ（基礎）
  for(let i=0;i<4;i++){ addPit(X+400+i*300, 120+Math.random()*80); }
  X += 1800;

  // --- Stage 2: 高壁ジャンプ連打
  for(let i=0;i<5;i++){
    const w=26+Math.random()*12, h=60+Math.random()*80;
    addWall(X+300+i*260, w, h);
  }
  X += 1800;

  // --- Stage 3: ドローン回廊（上下にうねる）
  for(let i=0;i<6;i++){
    addDrone(X+300+i*220, H-(80+Math.random()*120), 18+Math.random()*16);
  }
  addKey(X+820, H-160); // KEY#1
  X += 1700;

  // --- Stage 4: 縦レーザー・シャッター
  for(let i=0;i<5;i++){
    // 到着時にOFF窓が来るよう位相調整（+少し余裕）
    const gx = X+300+i*260;
    const arrive = gx / SPEED;
    const ideal  = (arrive - 0.25) % L_PERIOD;
    const phase  = (L_PERIOD - ideal) % L_PERIOD;
    addLaser(gx, phase);
  }
  X += 1800;

  // --- Stage 5: 崩落足場 over ピット
  for(let i=0;i<4;i++){
    const px0 = X+280+i*320, pw = 180;
    addPit(px0, pw);
    addFragile(px0-30, H-130, 80);          // 左浮島（踏むと0.35s後に落下）
    addFragile(px0+pw-50, H-120, 70);       // 右浮島
  }
  X += 1900;

  // --- Stage 6: 上昇気流で超ジャンプ
  addUp(X+420, 260);
  addUp(X+900, 220);
  addKey(X+960, H-220); // KEY#2（上昇気流を使って取る）
  X += 1600;

  // --- Stage 7: 落下ボムゾーン
  for(let i=0;i<8;i++){ addBomb(X+280+i*160, i*0.25); }
  X += 1700;

  // --- Stage 8: トンネル＋横レーザー（天井下に細道）
  for(let i=0;i<5;i++){
    const y = H-130, w = 140;
    addXLaser(X+340+i*240, y, w, 2.0, 0.7, Math.random()*2.0);
  }
  X += 1700;

  // --- Stage 9: ドローン十字路＋キー
  for(let i=0;i<5;i++){
    addDrone(X+300+i*240, H-(90+Math.random()*110), 22);
  }
  addKey(X+760, H-170); // KEY#3
  X += 1600;

  // --- Stage 10: 混合 → ゲート → ゴール
  // ピット＋縦レーザー2＋ノコ（ドローン）2
  addPit(X+300, 180);
  addLaser(X+560, 0.0);
  addLaser(X+820, 0.6);
  addDrone(X+980, H-140, 20);
  addDrone(X+1180, H-120, 26);

  // ゲート＆ゴール
  gate = {x:X+1380, w:24, y:0, h:cv.clientHeight};   // キー3でスルー可（描画は緑）
  goal = {x:X+1500, w:UNIT()*1.2, h:UNIT()*1.6};

  X += 1700;

  WORLD_LEN = X;
}

/* ===== ユーティリティ ===== */
function inPit(xCenter){
  for(const p of pits){ if (xCenter>=p.x && xCenter<=p.x+p.w) return true; }
  return false;
}
function rectOverlap(ax,ay,aw,ah,bx,by,bw,bh,f=0){
  return !(ax+aw-f<bx || ax+f>bx+bw || ay+ah-f<by || ay+f>by+bh);
}
function laserActive(L, t){
  const tt = (t + L.phase) % L.period;
  return !(tt <= L.off); // OFF窓の間は安全
}
function xlaserActive(XL, t){
  const tt = (t + XL.phase) % XL.period;
  return !(tt <= XL.off);
}

/* ===== 入力 ===== */
function jump(){
  if (!playing) return;
  if (onGround || coyote>0){ vy=JUMP_V; onGround=false; jumps=1; coyote=0; return; }
  if (jumps>0){ vy=DJUMP_V; jumps=0; }
}
cv.addEventListener('pointerdown', jump, {passive:true});
addEventListener('keydown', e=>{ if (e.code==='Space'){ e.preventDefault(); jump(); } }, {passive:false});

/* ===== ループ ===== */
function loop(ts){
  if (!playing) return;
  if (!last) last = ts;
  const dt = Math.min(0.033, (ts-last)/1000);
  last = ts;
  timeNow = (ts - t0)/1000;
  timeEl.textContent = timeNow.toFixed(1);

  // 前進
  const vx = SPEED*dt;
  px += vx;

  // 基本床 or ピット
  const gy = groundY() - PH;
  const isPit = inPit(px + PW/2);

  // プラットフォーム（トップ判定 / 崩落）
  let groundedOnPlat = false;
  for(const p of plats){
    // 横に重なる＆上から入る＆足元が十分近い
    const onTop = (px+PW > p.x && px < p.x+p.w) && (py+PH <= p.y+8) && (py+PH+vy*dt >= p.y);
    if (onTop){
      py = p.y - PH; vy=0; groundedOnPlat=true; onGround=true; jumps=2; coyote=0;
      if (p.fragile && !p.hit){ p.hit=true; p.vanishAt = timeNow + (p.ttl||0.3); }
    }
    // 崩落処理
    if (p.fragile && p.hit && timeNow >= p.vanishAt){
      p.h = 0; p.w = 0; // 消す（簡易）
    }
  }

  // 上昇気流
  for(const u of updrafts){
    if (px+PW > u.x && px < u.x+u.w){
      vy += (UPDRAFT_V - vy)*0.06; // ゆるく上へ吸い上げ
    }
  }

  // 重力
  vy += GRAVITY*dt;
  py += vy*dt;

  // 地面着地
  if (!isPit && !groundedOnPlat){
    if (py >= gy){ py=gy; vy=0; if(!onGround){ onGround=true; jumps=2; } }
  }else{
    // ピット空間：落下中
    onGround=false; if (onGround===false) coyote = Math.max(0, coyote - dt);
  }

  // 奈落落下
  if (py > cv.clientHeight + UNIT()*4){ fail('奈落に落ちた…'); return; }

  // ドローン衝突
  for(const d of drones){
    d.t += dt; const y = d.baseY + Math.sin(d.t*2.6)*d.amp;
    const bx=d.x, by=y, bw=SAW_R*2, bh=SAW_R*2;
    if (rectOverlap(px,py,PW,PH,bx-SAWR,b y-SAWR,bw,bh,HIT_F)){ /* spacing helper */ }
  }
  // ↑上の可読性のため、実際の判定を下でまとめて描画時と同じ式で行う
  for(const d of drones){
    const y = d.baseY + Math.sin(d.t*2.6)*d.amp;
    if (rectOverlap(px,py,PW,PH, d.x-SAWR(), y-SAWR(), SAWR()*2, SAWR()*2, HIT_F)){
      fail('ドローン（ノコ）に当たった…'); return;
    }
  }
  function SAWR(){ return SAW_R; }

  // 縦レーザー
  for(const L of lasers){
    if (px + PW < L.x - GATE_W*2 || px > L.x + GATE_W*2) continue;
    if (laserActive(L, timeNow)){
      if (rectOverlap(px,py,PW,PH, L.x-GATE_W/2, 0, GATE_W, cv.clientHeight, HIT_F)){
        fail('レーザーに焼かれた…'); return;
      }
    }
  }

  // 横レーザー
  for(const XL of xlasers){
    if (!xlaserActive(XL,timeNow)) continue;
    if (rectOverlap(px,py,PW,PH, XL.x, XL.y, XL.w, 12, HIT_F)){
      fail('横レーザーに当たった…'); return;
    }
  }

  // 壁（ぶつかったらアウト）
  for(const w of walls){
    if (rectOverlap(px,py,PW,PH, w.x, groundY()-w.h, w.w, w.h, HIT_F)){
      fail('壁に激突…'); return;
    }
  }

  // ボム（近づいたら武装→落下）
  for(const b of bombs){
    if (!b.armed && px > b.x - 300){ b.armed=true; b.t0=timeNow + (b.delay||0); b.y=-40; }
    if (b.armed && timeNow>=b.t0){ b.y += b.v*dt; }
    if (rectOverlap(px,py,PW,PH, b.x-10, b.y-10, 20,20, HIT_F)){
      fail('爆弾に直撃…'); return;
    }
  }

  // キー取得
  for(const k of keysArr){
    if (k.taken) continue;
    const dx=Math.abs((k.x)-(px+PW/2)), dy=Math.abs((k.y)-(py+PH/2));
    if (dx < (PW/2 + k.r) && dy < (PH/2 + k.r)){
      k.taken=true; keys++; keysEl.textContent = keys;
    }
  }

  // ゲート（キー3で通過、足りないと失敗）
  if (gate){
    if (px+PW >= gate.x && px <= gate.x+gate.w){
      if (keys < 3){ fail('キーが足りない！ 3つ集めよう'); return; }
    }
  }

  // ゴール
  if (goal && px+PW >= goal.x){
    success(); return;
  }

  // カメラと進捗
  camX = Math.max(0, Math.min(px - cv.clientWidth*0.4, WORLD_LEN - cv.clientWidth));
  prog = Math.max(0, Math.min(100, Math.round(px / WORLD_LEN * 100)));
  progEl.textContent = prog;

  drawScene();
  raf = requestAnimationFrame(loop);
}

/* ===== 描画 ===== */
function drawScene(){
  const w = cv.clientWidth, h = cv.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#10253f'); g.addColorStop(1,'#0c182b');
  ctx.fillStyle=g; ctx.fillRect(0,0,w,h);

  // 地面
  ctx.fillStyle='#0e243a';
  ctx.fillRect(0,h-GROUND_H,w,GROUND_H);

  // ピット
  ctx.fillStyle='#061220';
  pits.forEach(p=> ctx.fillRect(p.x - camX, h-GROUND_H, p.w, GROUND_H));

  // 壁
  ctx.fillStyle='#ef4444';
  walls.forEach(b=> ctx.fillRect(b.x - camX, groundY()-b.h, b.w, b.h));

  // プラットフォーム
  plats.forEach(p=>{
    ctx.fillStyle = p.fragile ? '#f59e0b' : '#22c55e';
    ctx.fillRect(p.x - camX, p.y, p.w, p.h);
  });

  // 上昇気流
  updrafts.forEach(u=>{
    const x=u.x - camX;
    const grad=ctx.createLinearGradient(x,0,x+u.w,0);
    grad.addColorStop(0,'rgba(59,130,246,.15)');
    grad.addColorStop(0.5,'rgba(59,130,246,.35)');
    grad.addColorStop(1,'rgba(59,130,246,.15)');
    ctx.fillStyle=grad; ctx.fillRect(x,0,u.w,h);
  });

  // 縦レーザー
  lasers.forEach(L=>{
    const x=L.x - camX - GATE_W/2;
    // 支柱
    ctx.fillStyle='#1f2d46';
    ctx.fillRect(x-6,0,6,h); ctx.fillRect(x+GATE_W,0,6,h);
    if (laserActive(L,timeNow)){
      ctx.fillStyle='rgba(239,68,68,0.9)';
      ctx.fillRect(x,0,GATE_W,h);
      const gg=ctx.createLinearGradient(x,0,x+GATE_W,0);
      gg.addColorStop(0,'rgba(239,68,68,.15)');
      gg.addColorStop(0.5,'rgba(239,68,68,.35)');
      gg.addColorStop(1,'rgba(239,68,68,.15)');
      ctx.fillStyle=gg; ctx.fillRect(x-10,0,GATE_W+20,h);
    }
  });

  // 横レーザー
  xlasers.forEach(L=>{
    const x=L.x - camX;
    ctx.fillStyle='#1f2d46'; ctx.fillRect(x, L.y-8, L.w, 8);
    if (xlaserActive(L,timeNow)){
      ctx.fillStyle='rgba(239,68,68,0.9)'; ctx.fillRect(x, L.y, L.w, 12);
    }
  });

  // ドローン（ノコ）
  drones.forEach(d=>{
    const y=d.baseY + Math.sin(d.t*2.6)*d.amp;
    const x=d.x - camX;
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='#ef4444';
    for(let i=0;i<8;i++){
      ctx.rotate(Math.PI/4);
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-SAW_R); ctx.lineTo(SAW_R*0.75,-SAW_R*0.65); ctx.closePath(); ctx.fill();
    }
    ctx.restore();
  });

  // ボム
  bombs.forEach(b=>{
    const x=b.x - camX;
    ctx.fillStyle='#fbbf24';
    ctx.fillRect(x-10, b.y-10, 20, 20);
  });

  // キー
  keysArr.forEach(k=>{
    if (k.taken) return;
    const x=k.x - camX, y=k.y;
    ctx.beginPath(); ctx.arc(x,y,k.r,0,Math.PI*2); ctx.closePath();
    ctx.fillStyle='#eab308'; ctx.fill();
    ctx.lineWidth=2; ctx.strokeStyle='#fde68a'; ctx.stroke();
  });

  // ゲート＆ゴール
  if (gate){
    const x=gate.x - camX;
    ctx.fillStyle = (keys>=3)? '#22c55e':'#ef4444';
    ctx.fillRect(x,0,gate.w,h);
  }
  if (goal){
    const gx = goal.x - camX;
    ctx.fillStyle = '#22c55e';
    ctx.fillRect(gx, groundY()-goal.h, 6, goal.h);
    ctx.fillStyle = '#86efac';
    ctx.fillRect(gx+6, groundY()-goal.h, goal.w-6, 10);
  }

  // プレイヤー
  ctx.fillStyle='#22d3ee';
  ctx.fillRect(px - camX, py, PW, PH);

  // ガイド
  ctx.strokeStyle='rgba(255,255,255,.10)';
  ctx.beginPath(); ctx.moveTo(w*0.4,0); ctx.lineTo(w*0.4,h); ctx.stroke();
}

/* ===== 成否 ===== */
function fail(msg){
  playing=false;
  ovMsg.textContent='失敗…';
  ovSub.textContent = msg + '（焦らず2段ジャンプと停止窓を活用）';
  ov.style.display='grid';
}
function success(){
  playing=false;
  grantSecret70();
  ovMsg.textContent='解放成功！ #70 が使えるようになった';
  ovSub.textContent='おめでとう！ 図鑑で選択できます。';
  ov.style.display='grid';
}

/* ===== 開始/初期化 ===== */
function resetGame(){
  cancelAnimationFrame(raf);
  playing=false; t0=0; last=0; timeNow=0; prog=0; keys=0;
  px=90; py=groundY()-PH; vy=0; onGround=true; jumps=2; coyote=0; camX=0;
  timeEl.textContent='0.0'; progEl.textContent='0'; keysEl.textContent='0';
  buildStage();
  drawScene();
  ov.style.display='none';
}
function start(){
  resetGame();
  playing=true; t0=performance.now(); last=t0;
  raf = requestAnimationFrame(loop);
}

document.getElementById('startBtn').addEventListener('click', start);
document.getElementById('retryBtn').addEventListener('click', start);
document.getElementById('resetBtn').addEventListener('click', ()=>{
  if (confirm('本当に #70 の解放をリセットしますか？')){ resetSecret70(); alert('リセットしました。'); }
});

/* 初期描画 */
resetGame();
</script>
</body>
</html>
